(*
 Autogenerated by Thrift Compiler (0.9.0)

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
open Cassandra_types

(* HELPER FUNCTIONS AND STRUCTURES *)

class login_args =
object (self)
  val mutable _auth_request : authenticationRequest option = None
  method get_auth_request = _auth_request
  method grab_auth_request = match _auth_request with None->raise (Field_empty "login_args.auth_request") | Some _x452 -> _x452
  method set_auth_request _x452 = _auth_request <- Some _x452
  method unset_auth_request = _auth_request <- None
  method reset_auth_request = _auth_request <- None

  method copy =
      let _new = Oo.copy self in
      if _auth_request <> None then
        _new#set_auth_request self#grab_auth_request#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_args";
    (match _auth_request with 
    | None -> raise (Field_empty "login_args._auth_request")
    | Some _v -> 
      oprot#writeFieldBegin("auth_request",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_args (iprot : Protocol.t) =
  let _str455 = new login_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t456,_id457) = iprot#readFieldBegin in
        if _t456 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id457 with 
          | 1 -> (if _t456 = Protocol.T_STRUCT then
              _str455#set_auth_request (read_authenticationRequest iprot)
            else
              iprot#skip _t456)
          | _ -> iprot#skip _t456);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str455

class login_result =
object (self)
  val mutable _authnx : authenticationException option = None
  method get_authnx = _authnx
  method grab_authnx = match _authnx with None->raise (Field_empty "login_result.authnx") | Some _x458 -> _x458
  method set_authnx _x458 = _authnx <- Some _x458
  method unset_authnx = _authnx <- None
  method reset_authnx = _authnx <- None

  val mutable _authzx : authorizationException option = None
  method get_authzx = _authzx
  method grab_authzx = match _authzx with None->raise (Field_empty "login_result.authzx") | Some _x459 -> _x459
  method set_authzx _x459 = _authzx <- Some _x459
  method unset_authzx = _authzx <- None
  method reset_authzx = _authzx <- None

  method copy =
      let _new = Oo.copy self in
      if _authnx <> None then
        _new#set_authnx self#grab_authnx#copy;
      if _authzx <> None then
        _new#set_authzx self#grab_authzx#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "login_result";
    (match _authnx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authnx",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _authzx with None -> () | Some _v -> 
      oprot#writeFieldBegin("authzx",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_login_result (iprot : Protocol.t) =
  let _str462 = new login_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t463,_id464) = iprot#readFieldBegin in
        if _t463 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id464 with 
          | 1 -> (if _t463 = Protocol.T_STRUCT then
              _str462#set_authnx (read_authenticationException iprot)
            else
              iprot#skip _t463)
          | 2 -> (if _t463 = Protocol.T_STRUCT then
              _str462#set_authzx (read_authorizationException iprot)
            else
              iprot#skip _t463)
          | _ -> iprot#skip _t463);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str462

class set_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "set_keyspace_args.keyspace") | Some _x465 -> _x465
  method set_keyspace _x465 = _keyspace <- Some _x465
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_keyspace_args";
    (match _keyspace with 
    | None -> raise (Field_empty "set_keyspace_args._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_keyspace_args (iprot : Protocol.t) =
  let _str468 = new set_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t469,_id470) = iprot#readFieldBegin in
        if _t469 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id470 with 
          | 1 -> (if _t469 = Protocol.T_STRING then
              _str468#set_keyspace iprot#readString
            else
              iprot#skip _t469)
          | _ -> iprot#skip _t469);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str468

class set_keyspace_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "set_keyspace_result.ire") | Some _x471 -> _x471
  method set_ire _x471 = _ire <- Some _x471
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_keyspace_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_keyspace_result (iprot : Protocol.t) =
  let _str474 = new set_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t475,_id476) = iprot#readFieldBegin in
        if _t475 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id476 with 
          | 1 -> (if _t475 = Protocol.T_STRUCT then
              _str474#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t475)
          | _ -> iprot#skip _t475);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str474

class get_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_args.key") | Some _x477 -> _x477
  method set_key _x477 = _key <- Some _x477
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "get_args.column_path") | Some _x478 -> _x478
  method set_column_path _x478 = _column_path <- Some _x478
  method unset_column_path = _column_path <- None
  method reset_column_path = _column_path <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x479 = _consistency_level <- _x479
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_path <> None then
        _new#set_column_path self#grab_column_path#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_args";
    (match _key with 
    | None -> raise (Field_empty "get_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with 
    | None -> raise (Field_empty "get_args._column_path")
    | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,3);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_args (iprot : Protocol.t) =
  let _str482 = new get_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t483,_id484) = iprot#readFieldBegin in
        if _t483 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id484 with 
          | 1 -> (if _t483 = Protocol.T_STRING then
              _str482#set_key iprot#readString
            else
              iprot#skip _t483)
          | 2 -> (if _t483 = Protocol.T_STRUCT then
              _str482#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t483)
          | 3 -> (if _t483 = Protocol.T_I32 then
              _str482#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t483)
          | _ -> iprot#skip _t483);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str482

class get_result =
object (self)
  val mutable _success : columnOrSuperColumn option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_result.success") | Some _x485 -> _x485
  method set_success _x485 = _success <- Some _x485
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_result.ire") | Some _x486 -> _x486
  method set_ire _x486 = _ire <- Some _x486
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "get_result.nfe") | Some _x487 -> _x487
  method set_nfe _x487 = _nfe <- Some _x487
  method unset_nfe = _nfe <- None
  method reset_nfe = _nfe <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_result.ue") | Some _x488 -> _x488
  method set_ue _x488 = _ue <- Some _x488
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_result.te") | Some _x489 -> _x489
  method set_te _x489 = _te <- Some _x489
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _nfe <> None then
        _new#set_nfe self#grab_nfe#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_result (iprot : Protocol.t) =
  let _str492 = new get_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t493,_id494) = iprot#readFieldBegin in
        if _t493 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id494 with 
          | 0 -> (if _t493 = Protocol.T_STRUCT then
              _str492#set_success (read_columnOrSuperColumn iprot)
            else
              iprot#skip _t493)
          | 1 -> (if _t493 = Protocol.T_STRUCT then
              _str492#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t493)
          | 2 -> (if _t493 = Protocol.T_STRUCT then
              _str492#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t493)
          | 3 -> (if _t493 = Protocol.T_STRUCT then
              _str492#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t493)
          | 4 -> (if _t493 = Protocol.T_STRUCT then
              _str492#set_te (read_timedOutException iprot)
            else
              iprot#skip _t493)
          | _ -> iprot#skip _t493);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str492

class get_slice_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_slice_args.key") | Some _x495 -> _x495
  method set_key _x495 = _key <- Some _x495
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_slice_args.column_parent") | Some _x496 -> _x496
  method set_column_parent _x496 = _column_parent <- Some _x496
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_slice_args.predicate") | Some _x497 -> _x497
  method set_predicate _x497 = _predicate <- Some _x497
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x498 = _consistency_level <- _x498
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_args";
    (match _key with 
    | None -> raise (Field_empty "get_slice_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "get_slice_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "get_slice_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_args (iprot : Protocol.t) =
  let _str501 = new get_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t502,_id503) = iprot#readFieldBegin in
        if _t502 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id503 with 
          | 1 -> (if _t502 = Protocol.T_STRING then
              _str501#set_key iprot#readString
            else
              iprot#skip _t502)
          | 2 -> (if _t502 = Protocol.T_STRUCT then
              _str501#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t502)
          | 3 -> (if _t502 = Protocol.T_STRUCT then
              _str501#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t502)
          | 4 -> (if _t502 = Protocol.T_I32 then
              _str501#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t502)
          | _ -> iprot#skip _t502);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str501

class get_slice_result =
object (self)
  val mutable _success : columnOrSuperColumn list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_slice_result.success") | Some _x504 -> _x504
  method set_success _x504 = _success <- Some _x504
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_slice_result.ire") | Some _x505 -> _x505
  method set_ire _x505 = _ire <- Some _x505
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_slice_result.ue") | Some _x506 -> _x506
  method set_ue _x506 = _ue <- Some _x506
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_slice_result.te") | Some _x507 -> _x507
  method set_te _x507 = _te <- Some _x507
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter510 ->         _iter510#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_slice_result (iprot : Protocol.t) =
  let _str511 = new get_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t512,_id513) = iprot#readFieldBegin in
        if _t512 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id513 with 
          | 0 -> (if _t512 = Protocol.T_LIST then
              _str511#set_success 
                (let (_etype517,_size514) = iprot#readListBegin in
                  let _con518 = (Array.to_list (Array.init _size514 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con518)
            else
              iprot#skip _t512)
          | 1 -> (if _t512 = Protocol.T_STRUCT then
              _str511#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t512)
          | 2 -> (if _t512 = Protocol.T_STRUCT then
              _str511#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t512)
          | 3 -> (if _t512 = Protocol.T_STRUCT then
              _str511#set_te (read_timedOutException iprot)
            else
              iprot#skip _t512)
          | _ -> iprot#skip _t512);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str511

class get_count_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "get_count_args.key") | Some _x519 -> _x519
  method set_key _x519 = _key <- Some _x519
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_count_args.column_parent") | Some _x520 -> _x520
  method set_column_parent _x520 = _column_parent <- Some _x520
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_count_args.predicate") | Some _x521 -> _x521
  method set_predicate _x521 = _predicate <- Some _x521
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x522 = _consistency_level <- _x522
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_args";
    (match _key with 
    | None -> raise (Field_empty "get_count_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "get_count_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "get_count_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_args (iprot : Protocol.t) =
  let _str525 = new get_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t526,_id527) = iprot#readFieldBegin in
        if _t526 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id527 with 
          | 1 -> (if _t526 = Protocol.T_STRING then
              _str525#set_key iprot#readString
            else
              iprot#skip _t526)
          | 2 -> (if _t526 = Protocol.T_STRUCT then
              _str525#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t526)
          | 3 -> (if _t526 = Protocol.T_STRUCT then
              _str525#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t526)
          | 4 -> (if _t526 = Protocol.T_I32 then
              _str525#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t526)
          | _ -> iprot#skip _t526);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str525

class get_count_result =
object (self)
  val mutable _success : Int32.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_count_result.success") | Some _x528 -> _x528
  method set_success _x528 = _success <- Some _x528
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_count_result.ire") | Some _x529 -> _x529
  method set_ire _x529 = _ire <- Some _x529
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_count_result.ue") | Some _x530 -> _x530
  method set_ue _x530 = _ue <- Some _x530
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_count_result.te") | Some _x531 -> _x531
  method set_te _x531 = _te <- Some _x531
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_I32,0);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_count_result (iprot : Protocol.t) =
  let _str534 = new get_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t535,_id536) = iprot#readFieldBegin in
        if _t535 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id536 with 
          | 0 -> (if _t535 = Protocol.T_I32 then
              _str534#set_success iprot#readI32
            else
              iprot#skip _t535)
          | 1 -> (if _t535 = Protocol.T_STRUCT then
              _str534#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t535)
          | 2 -> (if _t535 = Protocol.T_STRUCT then
              _str534#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t535)
          | 3 -> (if _t535 = Protocol.T_STRUCT then
              _str534#set_te (read_timedOutException iprot)
            else
              iprot#skip _t535)
          | _ -> iprot#skip _t535);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str534

class multiget_slice_args =
object (self)
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_slice_args.keys") | Some _x537 -> _x537
  method set_keys _x537 = _keys <- Some _x537
  method unset_keys = _keys <- None
  method reset_keys = _keys <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_slice_args.column_parent") | Some _x538 -> _x538
  method set_column_parent _x538 = _column_parent <- Some _x538
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_slice_args.predicate") | Some _x539 -> _x539
  method set_predicate _x539 = _predicate <- Some _x539
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x540 = _consistency_level <- _x540
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_args";
    (match _keys with 
    | None -> raise (Field_empty "multiget_slice_args._keys")
    | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter543 ->         oprot#writeString(_iter543);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "multiget_slice_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "multiget_slice_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_args (iprot : Protocol.t) =
  let _str544 = new multiget_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t545,_id546) = iprot#readFieldBegin in
        if _t545 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id546 with 
          | 1 -> (if _t545 = Protocol.T_LIST then
              _str544#set_keys 
                (let (_etype550,_size547) = iprot#readListBegin in
                  let _con551 = (Array.to_list (Array.init _size547 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con551)
            else
              iprot#skip _t545)
          | 2 -> (if _t545 = Protocol.T_STRUCT then
              _str544#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t545)
          | 3 -> (if _t545 = Protocol.T_STRUCT then
              _str544#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t545)
          | 4 -> (if _t545 = Protocol.T_I32 then
              _str544#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t545)
          | _ -> iprot#skip _t545);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str544

class multiget_slice_result =
object (self)
  val mutable _success : (string,columnOrSuperColumn list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_slice_result.success") | Some _x552 -> _x552
  method set_success _x552 = _success <- Some _x552
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_slice_result.ire") | Some _x553 -> _x553
  method set_ire _x553 = _ire <- Some _x553
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_slice_result.ue") | Some _x554 -> _x554
  method set_ue _x554 = _ue <- Some _x554
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_slice_result.te") | Some _x555 -> _x555
  method set_te _x555 = _te <- Some _x555
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success ((fun oh -> let nh = Hashtbl.create (Hashtbl.length oh) in Hashtbl.iter (fun k v -> Hashtbl.add nh k (List.map (fun x -> x#copy) v)) oh; nh) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter558 -> fun _viter559 -> 
        oprot#writeString(_kiter558);
        oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter559);
        List.iter (fun _iter560 ->           _iter560#write(oprot);
        ) _viter559;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_slice_result (iprot : Protocol.t) =
  let _str561 = new multiget_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t562,_id563) = iprot#readFieldBegin in
        if _t562 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id563 with 
          | 0 -> (if _t562 = Protocol.T_MAP then
              _str561#set_success 
                (let (_ktype565,_vtype566,_size564) = iprot#readMapBegin in
                let _con568 = Hashtbl.create _size564 in
                  for i = 1 to _size564 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype572,_size569) = iprot#readListBegin in
                        let _con573 = (Array.to_list (Array.init _size569 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                          iprot#readListEnd; _con573) in
                      Hashtbl.add _con568 _k _v
                  done; iprot#readMapEnd; _con568)
            else
              iprot#skip _t562)
          | 1 -> (if _t562 = Protocol.T_STRUCT then
              _str561#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t562)
          | 2 -> (if _t562 = Protocol.T_STRUCT then
              _str561#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t562)
          | 3 -> (if _t562 = Protocol.T_STRUCT then
              _str561#set_te (read_timedOutException iprot)
            else
              iprot#skip _t562)
          | _ -> iprot#skip _t562);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str561

class multiget_count_args =
object (self)
  val mutable _keys : string list option = None
  method get_keys = _keys
  method grab_keys = match _keys with None->raise (Field_empty "multiget_count_args.keys") | Some _x574 -> _x574
  method set_keys _x574 = _keys <- Some _x574
  method unset_keys = _keys <- None
  method reset_keys = _keys <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "multiget_count_args.column_parent") | Some _x575 -> _x575
  method set_column_parent _x575 = _column_parent <- Some _x575
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "multiget_count_args.predicate") | Some _x576 -> _x576
  method set_predicate _x576 = _predicate <- Some _x576
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x577 = _consistency_level <- _x577
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_count_args";
    (match _keys with 
    | None -> raise (Field_empty "multiget_count_args._keys")
    | Some _v -> 
      oprot#writeFieldBegin("keys",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter580 ->         oprot#writeString(_iter580);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "multiget_count_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "multiget_count_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_count_args (iprot : Protocol.t) =
  let _str581 = new multiget_count_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t582,_id583) = iprot#readFieldBegin in
        if _t582 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id583 with 
          | 1 -> (if _t582 = Protocol.T_LIST then
              _str581#set_keys 
                (let (_etype587,_size584) = iprot#readListBegin in
                  let _con588 = (Array.to_list (Array.init _size584 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con588)
            else
              iprot#skip _t582)
          | 2 -> (if _t582 = Protocol.T_STRUCT then
              _str581#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t582)
          | 3 -> (if _t582 = Protocol.T_STRUCT then
              _str581#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t582)
          | 4 -> (if _t582 = Protocol.T_I32 then
              _str581#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t582)
          | _ -> iprot#skip _t582);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str581

class multiget_count_result =
object (self)
  val mutable _success : (string,Int32.t) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "multiget_count_result.success") | Some _x589 -> _x589
  method set_success _x589 = _success <- Some _x589
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "multiget_count_result.ire") | Some _x590 -> _x590
  method set_ire _x590 = _ire <- Some _x590
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "multiget_count_result.ue") | Some _x591 -> _x591
  method set_ue _x591 = _ue <- Some _x591
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "multiget_count_result.te") | Some _x592 -> _x592
  method set_te _x592 = _te <- Some _x592
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (Hashtbl.copy self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "multiget_count_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_I32,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter595 -> fun _viter596 -> 
        oprot#writeString(_kiter595);
        oprot#writeI32(_viter596);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_multiget_count_result (iprot : Protocol.t) =
  let _str597 = new multiget_count_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t598,_id599) = iprot#readFieldBegin in
        if _t598 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id599 with 
          | 0 -> (if _t598 = Protocol.T_MAP then
              _str597#set_success 
                (let (_ktype601,_vtype602,_size600) = iprot#readMapBegin in
                let _con604 = Hashtbl.create _size600 in
                  for i = 1 to _size600 do
                    let _k = iprot#readString in
                    let _v = iprot#readI32 in
                      Hashtbl.add _con604 _k _v
                  done; iprot#readMapEnd; _con604)
            else
              iprot#skip _t598)
          | 1 -> (if _t598 = Protocol.T_STRUCT then
              _str597#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t598)
          | 2 -> (if _t598 = Protocol.T_STRUCT then
              _str597#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t598)
          | 3 -> (if _t598 = Protocol.T_STRUCT then
              _str597#set_te (read_timedOutException iprot)
            else
              iprot#skip _t598)
          | _ -> iprot#skip _t598);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str597

class get_range_slices_args =
object (self)
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_range_slices_args.column_parent") | Some _x605 -> _x605
  method set_column_parent _x605 = _column_parent <- Some _x605
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "get_range_slices_args.predicate") | Some _x606 -> _x606
  method set_predicate _x606 = _predicate <- Some _x606
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  val mutable _range : keyRange option = None
  method get_range = _range
  method grab_range = match _range with None->raise (Field_empty "get_range_slices_args.range") | Some _x607 -> _x607
  method set_range _x607 = _range <- Some _x607
  method unset_range = _range <- None
  method reset_range = _range <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x608 = _consistency_level <- _x608
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
      if _range <> None then
        _new#set_range self#grab_range#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_args";
    (match _column_parent with 
    | None -> raise (Field_empty "get_range_slices_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _predicate with 
    | None -> raise (Field_empty "get_range_slices_args._predicate")
    | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _range with 
    | None -> raise (Field_empty "get_range_slices_args._range")
    | Some _v -> 
      oprot#writeFieldBegin("range",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_args (iprot : Protocol.t) =
  let _str611 = new get_range_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t612,_id613) = iprot#readFieldBegin in
        if _t612 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id613 with 
          | 1 -> (if _t612 = Protocol.T_STRUCT then
              _str611#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t612)
          | 2 -> (if _t612 = Protocol.T_STRUCT then
              _str611#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t612)
          | 3 -> (if _t612 = Protocol.T_STRUCT then
              _str611#set_range (read_keyRange iprot)
            else
              iprot#skip _t612)
          | 4 -> (if _t612 = Protocol.T_I32 then
              _str611#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t612)
          | _ -> iprot#skip _t612);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str611

class get_range_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_range_slices_result.success") | Some _x614 -> _x614
  method set_success _x614 = _success <- Some _x614
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_range_slices_result.ire") | Some _x615 -> _x615
  method set_ire _x615 = _ire <- Some _x615
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_range_slices_result.ue") | Some _x616 -> _x616
  method set_ue _x616 = _ue <- Some _x616
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_range_slices_result.te") | Some _x617 -> _x617
  method set_te _x617 = _te <- Some _x617
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_range_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter620 ->         _iter620#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_range_slices_result (iprot : Protocol.t) =
  let _str621 = new get_range_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t622,_id623) = iprot#readFieldBegin in
        if _t622 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id623 with 
          | 0 -> (if _t622 = Protocol.T_LIST then
              _str621#set_success 
                (let (_etype627,_size624) = iprot#readListBegin in
                  let _con628 = (Array.to_list (Array.init _size624 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con628)
            else
              iprot#skip _t622)
          | 1 -> (if _t622 = Protocol.T_STRUCT then
              _str621#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t622)
          | 2 -> (if _t622 = Protocol.T_STRUCT then
              _str621#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t622)
          | 3 -> (if _t622 = Protocol.T_STRUCT then
              _str621#set_te (read_timedOutException iprot)
            else
              iprot#skip _t622)
          | _ -> iprot#skip _t622);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str621

class get_paged_slice_args =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "get_paged_slice_args.column_family") | Some _x629 -> _x629
  method set_column_family _x629 = _column_family <- Some _x629
  method unset_column_family = _column_family <- None
  method reset_column_family = _column_family <- None

  val mutable _range : keyRange option = None
  method get_range = _range
  method grab_range = match _range with None->raise (Field_empty "get_paged_slice_args.range") | Some _x630 -> _x630
  method set_range _x630 = _range <- Some _x630
  method unset_range = _range <- None
  method reset_range = _range <- None

  val mutable _start_column : string option = None
  method get_start_column = _start_column
  method grab_start_column = match _start_column with None->raise (Field_empty "get_paged_slice_args.start_column") | Some _x631 -> _x631
  method set_start_column _x631 = _start_column <- Some _x631
  method unset_start_column = _start_column <- None
  method reset_start_column = _start_column <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x632 = _consistency_level <- _x632
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _range <> None then
        _new#set_range self#grab_range#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_paged_slice_args";
    (match _column_family with 
    | None -> raise (Field_empty "get_paged_slice_args._column_family")
    | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _range with 
    | None -> raise (Field_empty "get_paged_slice_args._range")
    | Some _v -> 
      oprot#writeFieldBegin("range",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _start_column with 
    | None -> raise (Field_empty "get_paged_slice_args._start_column")
    | Some _v -> 
      oprot#writeFieldBegin("start_column",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_paged_slice_args (iprot : Protocol.t) =
  let _str635 = new get_paged_slice_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t636,_id637) = iprot#readFieldBegin in
        if _t636 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id637 with 
          | 1 -> (if _t636 = Protocol.T_STRING then
              _str635#set_column_family iprot#readString
            else
              iprot#skip _t636)
          | 2 -> (if _t636 = Protocol.T_STRUCT then
              _str635#set_range (read_keyRange iprot)
            else
              iprot#skip _t636)
          | 3 -> (if _t636 = Protocol.T_STRING then
              _str635#set_start_column iprot#readString
            else
              iprot#skip _t636)
          | 4 -> (if _t636 = Protocol.T_I32 then
              _str635#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t636)
          | _ -> iprot#skip _t636);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str635

class get_paged_slice_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_paged_slice_result.success") | Some _x638 -> _x638
  method set_success _x638 = _success <- Some _x638
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_paged_slice_result.ire") | Some _x639 -> _x639
  method set_ire _x639 = _ire <- Some _x639
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_paged_slice_result.ue") | Some _x640 -> _x640
  method set_ue _x640 = _ue <- Some _x640
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_paged_slice_result.te") | Some _x641 -> _x641
  method set_te _x641 = _te <- Some _x641
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_paged_slice_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter644 ->         _iter644#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_paged_slice_result (iprot : Protocol.t) =
  let _str645 = new get_paged_slice_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t646,_id647) = iprot#readFieldBegin in
        if _t646 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id647 with 
          | 0 -> (if _t646 = Protocol.T_LIST then
              _str645#set_success 
                (let (_etype651,_size648) = iprot#readListBegin in
                  let _con652 = (Array.to_list (Array.init _size648 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con652)
            else
              iprot#skip _t646)
          | 1 -> (if _t646 = Protocol.T_STRUCT then
              _str645#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t646)
          | 2 -> (if _t646 = Protocol.T_STRUCT then
              _str645#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t646)
          | 3 -> (if _t646 = Protocol.T_STRUCT then
              _str645#set_te (read_timedOutException iprot)
            else
              iprot#skip _t646)
          | _ -> iprot#skip _t646);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str645

class get_indexed_slices_args =
object (self)
  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "get_indexed_slices_args.column_parent") | Some _x653 -> _x653
  method set_column_parent _x653 = _column_parent <- Some _x653
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _index_clause : indexClause option = None
  method get_index_clause = _index_clause
  method grab_index_clause = match _index_clause with None->raise (Field_empty "get_indexed_slices_args.index_clause") | Some _x654 -> _x654
  method set_index_clause _x654 = _index_clause <- Some _x654
  method unset_index_clause = _index_clause <- None
  method reset_index_clause = _index_clause <- None

  val mutable _column_predicate : slicePredicate option = None
  method get_column_predicate = _column_predicate
  method grab_column_predicate = match _column_predicate with None->raise (Field_empty "get_indexed_slices_args.column_predicate") | Some _x655 -> _x655
  method set_column_predicate _x655 = _column_predicate <- Some _x655
  method unset_column_predicate = _column_predicate <- None
  method reset_column_predicate = _column_predicate <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x656 = _consistency_level <- _x656
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _index_clause <> None then
        _new#set_index_clause self#grab_index_clause#copy;
      if _column_predicate <> None then
        _new#set_column_predicate self#grab_column_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_indexed_slices_args";
    (match _column_parent with 
    | None -> raise (Field_empty "get_indexed_slices_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _index_clause with 
    | None -> raise (Field_empty "get_indexed_slices_args._index_clause")
    | Some _v -> 
      oprot#writeFieldBegin("index_clause",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column_predicate with 
    | None -> raise (Field_empty "get_indexed_slices_args._column_predicate")
    | Some _v -> 
      oprot#writeFieldBegin("column_predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_indexed_slices_args (iprot : Protocol.t) =
  let _str659 = new get_indexed_slices_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t660,_id661) = iprot#readFieldBegin in
        if _t660 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id661 with 
          | 1 -> (if _t660 = Protocol.T_STRUCT then
              _str659#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t660)
          | 2 -> (if _t660 = Protocol.T_STRUCT then
              _str659#set_index_clause (read_indexClause iprot)
            else
              iprot#skip _t660)
          | 3 -> (if _t660 = Protocol.T_STRUCT then
              _str659#set_column_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t660)
          | 4 -> (if _t660 = Protocol.T_I32 then
              _str659#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t660)
          | _ -> iprot#skip _t660);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str659

class get_indexed_slices_result =
object (self)
  val mutable _success : keySlice list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "get_indexed_slices_result.success") | Some _x662 -> _x662
  method set_success _x662 = _success <- Some _x662
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "get_indexed_slices_result.ire") | Some _x663 -> _x663
  method set_ire _x663 = _ire <- Some _x663
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "get_indexed_slices_result.ue") | Some _x664 -> _x664
  method set_ue _x664 = _ue <- Some _x664
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "get_indexed_slices_result.te") | Some _x665 -> _x665
  method set_te _x665 = _te <- Some _x665
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "get_indexed_slices_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter668 ->         _iter668#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_get_indexed_slices_result (iprot : Protocol.t) =
  let _str669 = new get_indexed_slices_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t670,_id671) = iprot#readFieldBegin in
        if _t670 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id671 with 
          | 0 -> (if _t670 = Protocol.T_LIST then
              _str669#set_success 
                (let (_etype675,_size672) = iprot#readListBegin in
                  let _con676 = (Array.to_list (Array.init _size672 (fun _ -> (read_keySlice iprot)))) in
                    iprot#readListEnd; _con676)
            else
              iprot#skip _t670)
          | 1 -> (if _t670 = Protocol.T_STRUCT then
              _str669#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t670)
          | 2 -> (if _t670 = Protocol.T_STRUCT then
              _str669#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t670)
          | 3 -> (if _t670 = Protocol.T_STRUCT then
              _str669#set_te (read_timedOutException iprot)
            else
              iprot#skip _t670)
          | _ -> iprot#skip _t670);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str669

class insert_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "insert_args.key") | Some _x677 -> _x677
  method set_key _x677 = _key <- Some _x677
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "insert_args.column_parent") | Some _x678 -> _x678
  method set_column_parent _x678 = _column_parent <- Some _x678
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _column : column option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "insert_args.column") | Some _x679 -> _x679
  method set_column _x679 = _column <- Some _x679
  method unset_column = _column <- None
  method reset_column = _column <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x680 = _consistency_level <- _x680
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _column <> None then
        _new#set_column self#grab_column#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_args";
    (match _key with 
    | None -> raise (Field_empty "insert_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "insert_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column with 
    | None -> raise (Field_empty "insert_args._column")
    | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_args (iprot : Protocol.t) =
  let _str683 = new insert_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t684,_id685) = iprot#readFieldBegin in
        if _t684 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id685 with 
          | 1 -> (if _t684 = Protocol.T_STRING then
              _str683#set_key iprot#readString
            else
              iprot#skip _t684)
          | 2 -> (if _t684 = Protocol.T_STRUCT then
              _str683#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t684)
          | 3 -> (if _t684 = Protocol.T_STRUCT then
              _str683#set_column (read_column iprot)
            else
              iprot#skip _t684)
          | 4 -> (if _t684 = Protocol.T_I32 then
              _str683#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t684)
          | _ -> iprot#skip _t684);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str683

class insert_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "insert_result.ire") | Some _x686 -> _x686
  method set_ire _x686 = _ire <- Some _x686
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "insert_result.ue") | Some _x687 -> _x687
  method set_ue _x687 = _ue <- Some _x687
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "insert_result.te") | Some _x688 -> _x688
  method set_te _x688 = _te <- Some _x688
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "insert_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_insert_result (iprot : Protocol.t) =
  let _str691 = new insert_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t692,_id693) = iprot#readFieldBegin in
        if _t692 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id693 with 
          | 1 -> (if _t692 = Protocol.T_STRUCT then
              _str691#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t692)
          | 2 -> (if _t692 = Protocol.T_STRUCT then
              _str691#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t692)
          | 3 -> (if _t692 = Protocol.T_STRUCT then
              _str691#set_te (read_timedOutException iprot)
            else
              iprot#skip _t692)
          | _ -> iprot#skip _t692);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str691

class add_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "add_args.key") | Some _x694 -> _x694
  method set_key _x694 = _key <- Some _x694
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_parent : columnParent option = None
  method get_column_parent = _column_parent
  method grab_column_parent = match _column_parent with None->raise (Field_empty "add_args.column_parent") | Some _x695 -> _x695
  method set_column_parent _x695 = _column_parent <- Some _x695
  method unset_column_parent = _column_parent <- None
  method reset_column_parent = _column_parent <- None

  val mutable _column : counterColumn option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "add_args.column") | Some _x696 -> _x696
  method set_column _x696 = _column <- Some _x696
  method unset_column = _column <- None
  method reset_column = _column <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x697 = _consistency_level <- _x697
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_parent <> None then
        _new#set_column_parent self#grab_column_parent#copy;
      if _column <> None then
        _new#set_column self#grab_column#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "add_args";
    (match _key with 
    | None -> raise (Field_empty "add_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_parent with 
    | None -> raise (Field_empty "add_args._column_parent")
    | Some _v -> 
      oprot#writeFieldBegin("column_parent",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _column with 
    | None -> raise (Field_empty "add_args._column")
    | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_add_args (iprot : Protocol.t) =
  let _str700 = new add_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t701,_id702) = iprot#readFieldBegin in
        if _t701 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id702 with 
          | 1 -> (if _t701 = Protocol.T_STRING then
              _str700#set_key iprot#readString
            else
              iprot#skip _t701)
          | 2 -> (if _t701 = Protocol.T_STRUCT then
              _str700#set_column_parent (read_columnParent iprot)
            else
              iprot#skip _t701)
          | 3 -> (if _t701 = Protocol.T_STRUCT then
              _str700#set_column (read_counterColumn iprot)
            else
              iprot#skip _t701)
          | 4 -> (if _t701 = Protocol.T_I32 then
              _str700#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t701)
          | _ -> iprot#skip _t701);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str700

class add_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "add_result.ire") | Some _x703 -> _x703
  method set_ire _x703 = _ire <- Some _x703
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "add_result.ue") | Some _x704 -> _x704
  method set_ue _x704 = _ue <- Some _x704
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "add_result.te") | Some _x705 -> _x705
  method set_te _x705 = _te <- Some _x705
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "add_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_add_result (iprot : Protocol.t) =
  let _str708 = new add_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t709,_id710) = iprot#readFieldBegin in
        if _t709 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id710 with 
          | 1 -> (if _t709 = Protocol.T_STRUCT then
              _str708#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t709)
          | 2 -> (if _t709 = Protocol.T_STRUCT then
              _str708#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t709)
          | 3 -> (if _t709 = Protocol.T_STRUCT then
              _str708#set_te (read_timedOutException iprot)
            else
              iprot#skip _t709)
          | _ -> iprot#skip _t709);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str708

class remove_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_args.key") | Some _x711 -> _x711
  method set_key _x711 = _key <- Some _x711
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _column_path : columnPath option = None
  method get_column_path = _column_path
  method grab_column_path = match _column_path with None->raise (Field_empty "remove_args.column_path") | Some _x712 -> _x712
  method set_column_path _x712 = _column_path <- Some _x712
  method unset_column_path = _column_path <- None
  method reset_column_path = _column_path <- None

  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "remove_args.timestamp") | Some _x713 -> _x713
  method set_timestamp _x713 = _timestamp <- Some _x713
  method unset_timestamp = _timestamp <- None
  method reset_timestamp = _timestamp <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x714 = _consistency_level <- _x714
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _column_path <> None then
        _new#set_column_path self#grab_column_path#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_args";
    (match _key with 
    | None -> raise (Field_empty "remove_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_path with 
    | None -> raise (Field_empty "remove_args._column_path")
    | Some _v -> 
      oprot#writeFieldBegin("column_path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _timestamp with 
    | None -> raise (Field_empty "remove_args._timestamp")
    | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,4);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_args (iprot : Protocol.t) =
  let _str717 = new remove_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t718,_id719) = iprot#readFieldBegin in
        if _t718 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id719 with 
          | 1 -> (if _t718 = Protocol.T_STRING then
              _str717#set_key iprot#readString
            else
              iprot#skip _t718)
          | 2 -> (if _t718 = Protocol.T_STRUCT then
              _str717#set_column_path (read_columnPath iprot)
            else
              iprot#skip _t718)
          | 3 -> (if _t718 = Protocol.T_I64 then
              _str717#set_timestamp iprot#readI64
            else
              iprot#skip _t718)
          | 4 -> (if _t718 = Protocol.T_I32 then
              _str717#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t718)
          | _ -> iprot#skip _t718);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str717

class remove_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "remove_result.ire") | Some _x720 -> _x720
  method set_ire _x720 = _ire <- Some _x720
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "remove_result.ue") | Some _x721 -> _x721
  method set_ue _x721 = _ue <- Some _x721
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "remove_result.te") | Some _x722 -> _x722
  method set_te _x722 = _te <- Some _x722
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_result (iprot : Protocol.t) =
  let _str725 = new remove_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t726,_id727) = iprot#readFieldBegin in
        if _t726 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id727 with 
          | 1 -> (if _t726 = Protocol.T_STRUCT then
              _str725#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t726)
          | 2 -> (if _t726 = Protocol.T_STRUCT then
              _str725#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t726)
          | 3 -> (if _t726 = Protocol.T_STRUCT then
              _str725#set_te (read_timedOutException iprot)
            else
              iprot#skip _t726)
          | _ -> iprot#skip _t726);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str725

class remove_counter_args =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "remove_counter_args.key") | Some _x728 -> _x728
  method set_key _x728 = _key <- Some _x728
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _path : columnPath option = None
  method get_path = _path
  method grab_path = match _path with None->raise (Field_empty "remove_counter_args.path") | Some _x729 -> _x729
  method set_path _x729 = _path <- Some _x729
  method unset_path = _path <- None
  method reset_path = _path <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x730 = _consistency_level <- _x730
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _path <> None then
        _new#set_path self#grab_path#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_counter_args";
    (match _key with 
    | None -> raise (Field_empty "remove_counter_args._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _path with 
    | None -> raise (Field_empty "remove_counter_args._path")
    | Some _v -> 
      oprot#writeFieldBegin("path",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,3);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_counter_args (iprot : Protocol.t) =
  let _str733 = new remove_counter_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t734,_id735) = iprot#readFieldBegin in
        if _t734 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id735 with 
          | 1 -> (if _t734 = Protocol.T_STRING then
              _str733#set_key iprot#readString
            else
              iprot#skip _t734)
          | 2 -> (if _t734 = Protocol.T_STRUCT then
              _str733#set_path (read_columnPath iprot)
            else
              iprot#skip _t734)
          | 3 -> (if _t734 = Protocol.T_I32 then
              _str733#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t734)
          | _ -> iprot#skip _t734);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str733

class remove_counter_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "remove_counter_result.ire") | Some _x736 -> _x736
  method set_ire _x736 = _ire <- Some _x736
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "remove_counter_result.ue") | Some _x737 -> _x737
  method set_ue _x737 = _ue <- Some _x737
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "remove_counter_result.te") | Some _x738 -> _x738
  method set_te _x738 = _te <- Some _x738
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "remove_counter_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_remove_counter_result (iprot : Protocol.t) =
  let _str741 = new remove_counter_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t742,_id743) = iprot#readFieldBegin in
        if _t742 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id743 with 
          | 1 -> (if _t742 = Protocol.T_STRUCT then
              _str741#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t742)
          | 2 -> (if _t742 = Protocol.T_STRUCT then
              _str741#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t742)
          | 3 -> (if _t742 = Protocol.T_STRUCT then
              _str741#set_te (read_timedOutException iprot)
            else
              iprot#skip _t742)
          | _ -> iprot#skip _t742);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str741

class batch_mutate_args =
object (self)
  val mutable _mutation_map : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option = None
  method get_mutation_map = _mutation_map
  method grab_mutation_map = match _mutation_map with None->raise (Field_empty "batch_mutate_args.mutation_map") | Some _x744 -> _x744
  method set_mutation_map _x744 = _mutation_map <- Some _x744
  method unset_mutation_map = _mutation_map <- None
  method reset_mutation_map = _mutation_map <- None

  val mutable _consistency_level : ConsistencyLevel.t =   ConsistencyLevel.ONE
  method get_consistency_level = Some _consistency_level
  method grab_consistency_level = _consistency_level
  method set_consistency_level _x745 = _consistency_level <- _x745
  method reset_consistency_level = _consistency_level <-   ConsistencyLevel.ONE

  method copy =
      let _new = Oo.copy self in
      if _mutation_map <> None then
        _new#set_mutation_map ((fun oh -> let nh = Hashtbl.create (Hashtbl.length oh) in Hashtbl.iter (fun k v -> Hashtbl.add nh k ((fun oh -> let nh = Hashtbl.create (Hashtbl.length oh) in Hashtbl.iter (fun k v -> Hashtbl.add nh k (List.map (fun x -> x#copy) v)) oh; nh) v)) oh; nh) self#grab_mutation_map);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_args";
    (match _mutation_map with 
    | None -> raise (Field_empty "batch_mutate_args._mutation_map")
    | Some _v -> 
      oprot#writeFieldBegin("mutation_map",Protocol.T_MAP,1);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_MAP,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter748 -> fun _viter749 -> 
        oprot#writeString(_kiter748);
        oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _viter749);
        Hashtbl.iter (fun _kiter750 -> fun _viter751 -> 
          oprot#writeString(_kiter750);
          oprot#writeListBegin(Protocol.T_STRUCT,List.length _viter751);
          List.iter (fun _iter752 ->             _iter752#write(oprot);
          ) _viter751;
          oprot#writeListEnd;
        ) _viter749;
        oprot#writeMapEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("consistency_level",Protocol.T_I32,2);
      oprot#writeI32(ConsistencyLevel.to_i _consistency_level);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_args (iprot : Protocol.t) =
  let _str753 = new batch_mutate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t754,_id755) = iprot#readFieldBegin in
        if _t754 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id755 with 
          | 1 -> (if _t754 = Protocol.T_MAP then
              _str753#set_mutation_map 
                (let (_ktype757,_vtype758,_size756) = iprot#readMapBegin in
                let _con760 = Hashtbl.create _size756 in
                  for i = 1 to _size756 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_ktype762,_vtype763,_size761) = iprot#readMapBegin in
                      let _con765 = Hashtbl.create _size761 in
                        for i = 1 to _size761 do
                          let _k = iprot#readString in
                          let _v = 
                            (let (_etype769,_size766) = iprot#readListBegin in
                              let _con770 = (Array.to_list (Array.init _size766 (fun _ -> (read_mutation iprot)))) in
                                iprot#readListEnd; _con770) in
                            Hashtbl.add _con765 _k _v
                        done; iprot#readMapEnd; _con765) in
                      Hashtbl.add _con760 _k _v
                  done; iprot#readMapEnd; _con760)
            else
              iprot#skip _t754)
          | 2 -> (if _t754 = Protocol.T_I32 then
              _str753#set_consistency_level (ConsistencyLevel.of_i iprot#readI32)
            else
              iprot#skip _t754)
          | _ -> iprot#skip _t754);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str753

class batch_mutate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "batch_mutate_result.ire") | Some _x771 -> _x771
  method set_ire _x771 = _ire <- Some _x771
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "batch_mutate_result.ue") | Some _x772 -> _x772
  method set_ue _x772 = _ue <- Some _x772
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "batch_mutate_result.te") | Some _x773 -> _x773
  method set_te _x773 = _te <- Some _x773
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "batch_mutate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_batch_mutate_result (iprot : Protocol.t) =
  let _str776 = new batch_mutate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t777,_id778) = iprot#readFieldBegin in
        if _t777 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id778 with 
          | 1 -> (if _t777 = Protocol.T_STRUCT then
              _str776#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t777)
          | 2 -> (if _t777 = Protocol.T_STRUCT then
              _str776#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t777)
          | 3 -> (if _t777 = Protocol.T_STRUCT then
              _str776#set_te (read_timedOutException iprot)
            else
              iprot#skip _t777)
          | _ -> iprot#skip _t777);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str776

class truncate_args =
object (self)
  val mutable _cfname : string option = None
  method get_cfname = _cfname
  method grab_cfname = match _cfname with None->raise (Field_empty "truncate_args.cfname") | Some _x779 -> _x779
  method set_cfname _x779 = _cfname <- Some _x779
  method unset_cfname = _cfname <- None
  method reset_cfname = _cfname <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "truncate_args";
    (match _cfname with 
    | None -> raise (Field_empty "truncate_args._cfname")
    | Some _v -> 
      oprot#writeFieldBegin("cfname",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_truncate_args (iprot : Protocol.t) =
  let _str782 = new truncate_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t783,_id784) = iprot#readFieldBegin in
        if _t783 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id784 with 
          | 1 -> (if _t783 = Protocol.T_STRING then
              _str782#set_cfname iprot#readString
            else
              iprot#skip _t783)
          | _ -> iprot#skip _t783);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str782

class truncate_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "truncate_result.ire") | Some _x785 -> _x785
  method set_ire _x785 = _ire <- Some _x785
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "truncate_result.ue") | Some _x786 -> _x786
  method set_ue _x786 = _ue <- Some _x786
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "truncate_result.te") | Some _x787 -> _x787
  method set_te _x787 = _te <- Some _x787
  method unset_te = _te <- None
  method reset_te = _te <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "truncate_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_truncate_result (iprot : Protocol.t) =
  let _str790 = new truncate_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t791,_id792) = iprot#readFieldBegin in
        if _t791 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id792 with 
          | 1 -> (if _t791 = Protocol.T_STRUCT then
              _str790#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t791)
          | 2 -> (if _t791 = Protocol.T_STRUCT then
              _str790#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t791)
          | 3 -> (if _t791 = Protocol.T_STRUCT then
              _str790#set_te (read_timedOutException iprot)
            else
              iprot#skip _t791)
          | _ -> iprot#skip _t791);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str790

class describe_schema_versions_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_schema_versions_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_schema_versions_args (iprot : Protocol.t) =
  let _str795 = new describe_schema_versions_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t796,_id797) = iprot#readFieldBegin in
        if _t796 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id797 with 
          | _ -> iprot#skip _t796);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str795

class describe_schema_versions_result =
object (self)
  val mutable _success : (string,string list) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_schema_versions_result.success") | Some _x798 -> _x798
  method set_success _x798 = _success <- Some _x798
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_schema_versions_result.ire") | Some _x799 -> _x799
  method set_ire _x799 = _ire <- Some _x799
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (Hashtbl.copy self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_schema_versions_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_LIST,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter802 -> fun _viter803 -> 
        oprot#writeString(_kiter802);
        oprot#writeListBegin(Protocol.T_STRING,List.length _viter803);
        List.iter (fun _iter804 ->           oprot#writeString(_iter804);
        ) _viter803;
        oprot#writeListEnd;
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_schema_versions_result (iprot : Protocol.t) =
  let _str805 = new describe_schema_versions_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t806,_id807) = iprot#readFieldBegin in
        if _t806 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id807 with 
          | 0 -> (if _t806 = Protocol.T_MAP then
              _str805#set_success 
                (let (_ktype809,_vtype810,_size808) = iprot#readMapBegin in
                let _con812 = Hashtbl.create _size808 in
                  for i = 1 to _size808 do
                    let _k = iprot#readString in
                    let _v = 
                      (let (_etype816,_size813) = iprot#readListBegin in
                        let _con817 = (Array.to_list (Array.init _size813 (fun _ -> iprot#readString))) in
                          iprot#readListEnd; _con817) in
                      Hashtbl.add _con812 _k _v
                  done; iprot#readMapEnd; _con812)
            else
              iprot#skip _t806)
          | 1 -> (if _t806 = Protocol.T_STRUCT then
              _str805#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t806)
          | _ -> iprot#skip _t806);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str805

class describe_keyspaces_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_args (iprot : Protocol.t) =
  let _str820 = new describe_keyspaces_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t821,_id822) = iprot#readFieldBegin in
        if _t821 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id822 with 
          | _ -> iprot#skip _t821);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str820

class describe_keyspaces_result =
object (self)
  val mutable _success : ksDef list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspaces_result.success") | Some _x823 -> _x823
  method set_success _x823 = _success <- Some _x823
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_keyspaces_result.ire") | Some _x824 -> _x824
  method set_ire _x824 = _ire <- Some _x824
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspaces_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter827 ->         _iter827#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspaces_result (iprot : Protocol.t) =
  let _str828 = new describe_keyspaces_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t829,_id830) = iprot#readFieldBegin in
        if _t829 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id830 with 
          | 0 -> (if _t829 = Protocol.T_LIST then
              _str828#set_success 
                (let (_etype834,_size831) = iprot#readListBegin in
                  let _con835 = (Array.to_list (Array.init _size831 (fun _ -> (read_ksDef iprot)))) in
                    iprot#readListEnd; _con835)
            else
              iprot#skip _t829)
          | 1 -> (if _t829 = Protocol.T_STRUCT then
              _str828#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t829)
          | _ -> iprot#skip _t829);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str828

class describe_cluster_name_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_args (iprot : Protocol.t) =
  let _str838 = new describe_cluster_name_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t839,_id840) = iprot#readFieldBegin in
        if _t839 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id840 with 
          | _ -> iprot#skip _t839);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str838

class describe_cluster_name_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_cluster_name_result.success") | Some _x841 -> _x841
  method set_success _x841 = _success <- Some _x841
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_cluster_name_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_cluster_name_result (iprot : Protocol.t) =
  let _str844 = new describe_cluster_name_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t845,_id846) = iprot#readFieldBegin in
        if _t845 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id846 with 
          | 0 -> (if _t845 = Protocol.T_STRING then
              _str844#set_success iprot#readString
            else
              iprot#skip _t845)
          | _ -> iprot#skip _t845);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str844

class describe_version_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_args (iprot : Protocol.t) =
  let _str849 = new describe_version_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t850,_id851) = iprot#readFieldBegin in
        if _t850 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id851 with 
          | _ -> iprot#skip _t850);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str849

class describe_version_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_version_result.success") | Some _x852 -> _x852
  method set_success _x852 = _success <- Some _x852
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_version_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_version_result (iprot : Protocol.t) =
  let _str855 = new describe_version_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t856,_id857) = iprot#readFieldBegin in
        if _t856 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id857 with 
          | 0 -> (if _t856 = Protocol.T_STRING then
              _str855#set_success iprot#readString
            else
              iprot#skip _t856)
          | _ -> iprot#skip _t856);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str855

class describe_ring_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_ring_args.keyspace") | Some _x858 -> _x858
  method set_keyspace _x858 = _keyspace <- Some _x858
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_args";
    (match _keyspace with 
    | None -> raise (Field_empty "describe_ring_args._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_args (iprot : Protocol.t) =
  let _str861 = new describe_ring_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t862,_id863) = iprot#readFieldBegin in
        if _t862 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id863 with 
          | 1 -> (if _t862 = Protocol.T_STRING then
              _str861#set_keyspace iprot#readString
            else
              iprot#skip _t862)
          | _ -> iprot#skip _t862);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str861

class describe_ring_result =
object (self)
  val mutable _success : tokenRange list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_ring_result.success") | Some _x864 -> _x864
  method set_success _x864 = _success <- Some _x864
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_ring_result.ire") | Some _x865 -> _x865
  method set_ire _x865 = _ire <- Some _x865
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (List.map (fun x -> x#copy) self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_ring_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter868 ->         _iter868#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_ring_result (iprot : Protocol.t) =
  let _str869 = new describe_ring_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t870,_id871) = iprot#readFieldBegin in
        if _t870 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id871 with 
          | 0 -> (if _t870 = Protocol.T_LIST then
              _str869#set_success 
                (let (_etype875,_size872) = iprot#readListBegin in
                  let _con876 = (Array.to_list (Array.init _size872 (fun _ -> (read_tokenRange iprot)))) in
                    iprot#readListEnd; _con876)
            else
              iprot#skip _t870)
          | 1 -> (if _t870 = Protocol.T_STRUCT then
              _str869#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t870)
          | _ -> iprot#skip _t870);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str869

class describe_token_map_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_token_map_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_token_map_args (iprot : Protocol.t) =
  let _str879 = new describe_token_map_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t880,_id881) = iprot#readFieldBegin in
        if _t880 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id881 with 
          | _ -> iprot#skip _t880);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str879

class describe_token_map_result =
object (self)
  val mutable _success : (string,string) Hashtbl.t option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_token_map_result.success") | Some _x882 -> _x882
  method set_success _x882 = _success <- Some _x882
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_token_map_result.ire") | Some _x883 -> _x883
  method set_ire _x883 = _ire <- Some _x883
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success (Hashtbl.copy self#grab_success);
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_token_map_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_MAP,0);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter886 -> fun _viter887 -> 
        oprot#writeString(_kiter886);
        oprot#writeString(_viter887);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_token_map_result (iprot : Protocol.t) =
  let _str888 = new describe_token_map_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t889,_id890) = iprot#readFieldBegin in
        if _t889 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id890 with 
          | 0 -> (if _t889 = Protocol.T_MAP then
              _str888#set_success 
                (let (_ktype892,_vtype893,_size891) = iprot#readMapBegin in
                let _con895 = Hashtbl.create _size891 in
                  for i = 1 to _size891 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con895 _k _v
                  done; iprot#readMapEnd; _con895)
            else
              iprot#skip _t889)
          | 1 -> (if _t889 = Protocol.T_STRUCT then
              _str888#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t889)
          | _ -> iprot#skip _t889);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str888

class describe_partitioner_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_partitioner_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_partitioner_args (iprot : Protocol.t) =
  let _str898 = new describe_partitioner_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t899,_id900) = iprot#readFieldBegin in
        if _t899 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id900 with 
          | _ -> iprot#skip _t899);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str898

class describe_partitioner_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_partitioner_result.success") | Some _x901 -> _x901
  method set_success _x901 = _success <- Some _x901
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_partitioner_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_partitioner_result (iprot : Protocol.t) =
  let _str904 = new describe_partitioner_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t905,_id906) = iprot#readFieldBegin in
        if _t905 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id906 with 
          | 0 -> (if _t905 = Protocol.T_STRING then
              _str904#set_success iprot#readString
            else
              iprot#skip _t905)
          | _ -> iprot#skip _t905);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str904

class describe_snitch_args =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_snitch_args";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_snitch_args (iprot : Protocol.t) =
  let _str909 = new describe_snitch_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t910,_id911) = iprot#readFieldBegin in
        if _t910 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id911 with 
          | _ -> iprot#skip _t910);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str909

class describe_snitch_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_snitch_result.success") | Some _x912 -> _x912
  method set_success _x912 = _success <- Some _x912
  method unset_success = _success <- None
  method reset_success = _success <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_snitch_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_snitch_result (iprot : Protocol.t) =
  let _str915 = new describe_snitch_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t916,_id917) = iprot#readFieldBegin in
        if _t916 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id917 with 
          | 0 -> (if _t916 = Protocol.T_STRING then
              _str915#set_success iprot#readString
            else
              iprot#skip _t916)
          | _ -> iprot#skip _t916);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str915

class describe_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "describe_keyspace_args.keyspace") | Some _x918 -> _x918
  method set_keyspace _x918 = _keyspace <- Some _x918
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_args";
    (match _keyspace with 
    | None -> raise (Field_empty "describe_keyspace_args._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_args (iprot : Protocol.t) =
  let _str921 = new describe_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t922,_id923) = iprot#readFieldBegin in
        if _t922 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id923 with 
          | 1 -> (if _t922 = Protocol.T_STRING then
              _str921#set_keyspace iprot#readString
            else
              iprot#skip _t922)
          | _ -> iprot#skip _t922);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str921

class describe_keyspace_result =
object (self)
  val mutable _success : ksDef option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_keyspace_result.success") | Some _x924 -> _x924
  method set_success _x924 = _success <- Some _x924
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _nfe : notFoundException option = None
  method get_nfe = _nfe
  method grab_nfe = match _nfe with None->raise (Field_empty "describe_keyspace_result.nfe") | Some _x925 -> _x925
  method set_nfe _x925 = _nfe <- Some _x925
  method unset_nfe = _nfe <- None
  method reset_nfe = _nfe <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_keyspace_result.ire") | Some _x926 -> _x926
  method set_ire _x926 = _ire <- Some _x926
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
      if _nfe <> None then
        _new#set_nfe self#grab_nfe#copy;
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _nfe with None -> () | Some _v -> 
      oprot#writeFieldBegin("nfe",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_keyspace_result (iprot : Protocol.t) =
  let _str929 = new describe_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t930,_id931) = iprot#readFieldBegin in
        if _t930 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id931 with 
          | 0 -> (if _t930 = Protocol.T_STRUCT then
              _str929#set_success (read_ksDef iprot)
            else
              iprot#skip _t930)
          | 1 -> (if _t930 = Protocol.T_STRUCT then
              _str929#set_nfe (read_notFoundException iprot)
            else
              iprot#skip _t930)
          | 2 -> (if _t930 = Protocol.T_STRUCT then
              _str929#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t930)
          | _ -> iprot#skip _t930);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str929

class describe_splits_args =
object (self)
  val mutable _cfName : string option = None
  method get_cfName = _cfName
  method grab_cfName = match _cfName with None->raise (Field_empty "describe_splits_args.cfName") | Some _x932 -> _x932
  method set_cfName _x932 = _cfName <- Some _x932
  method unset_cfName = _cfName <- None
  method reset_cfName = _cfName <- None

  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "describe_splits_args.start_token") | Some _x933 -> _x933
  method set_start_token _x933 = _start_token <- Some _x933
  method unset_start_token = _start_token <- None
  method reset_start_token = _start_token <- None

  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "describe_splits_args.end_token") | Some _x934 -> _x934
  method set_end_token _x934 = _end_token <- Some _x934
  method unset_end_token = _end_token <- None
  method reset_end_token = _end_token <- None

  val mutable _keys_per_split : Int32.t option = None
  method get_keys_per_split = _keys_per_split
  method grab_keys_per_split = match _keys_per_split with None->raise (Field_empty "describe_splits_args.keys_per_split") | Some _x935 -> _x935
  method set_keys_per_split _x935 = _keys_per_split <- Some _x935
  method unset_keys_per_split = _keys_per_split <- None
  method reset_keys_per_split = _keys_per_split <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_args";
    (match _cfName with 
    | None -> raise (Field_empty "describe_splits_args._cfName")
    | Some _v -> 
      oprot#writeFieldBegin("cfName",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start_token with 
    | None -> raise (Field_empty "describe_splits_args._start_token")
    | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with 
    | None -> raise (Field_empty "describe_splits_args._end_token")
    | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _keys_per_split with 
    | None -> raise (Field_empty "describe_splits_args._keys_per_split")
    | Some _v -> 
      oprot#writeFieldBegin("keys_per_split",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_args (iprot : Protocol.t) =
  let _str938 = new describe_splits_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t939,_id940) = iprot#readFieldBegin in
        if _t939 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id940 with 
          | 1 -> (if _t939 = Protocol.T_STRING then
              _str938#set_cfName iprot#readString
            else
              iprot#skip _t939)
          | 2 -> (if _t939 = Protocol.T_STRING then
              _str938#set_start_token iprot#readString
            else
              iprot#skip _t939)
          | 3 -> (if _t939 = Protocol.T_STRING then
              _str938#set_end_token iprot#readString
            else
              iprot#skip _t939)
          | 4 -> (if _t939 = Protocol.T_I32 then
              _str938#set_keys_per_split iprot#readI32
            else
              iprot#skip _t939)
          | _ -> iprot#skip _t939);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str938

class describe_splits_result =
object (self)
  val mutable _success : string list option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "describe_splits_result.success") | Some _x941 -> _x941
  method set_success _x941 = _success <- Some _x941
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "describe_splits_result.ire") | Some _x942 -> _x942
  method set_ire _x942 = _ire <- Some _x942
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "describe_splits_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_LIST,0);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter945 ->         oprot#writeString(_iter945);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_describe_splits_result (iprot : Protocol.t) =
  let _str946 = new describe_splits_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t947,_id948) = iprot#readFieldBegin in
        if _t947 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id948 with 
          | 0 -> (if _t947 = Protocol.T_LIST then
              _str946#set_success 
                (let (_etype952,_size949) = iprot#readListBegin in
                  let _con953 = (Array.to_list (Array.init _size949 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con953)
            else
              iprot#skip _t947)
          | 1 -> (if _t947 = Protocol.T_STRUCT then
              _str946#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t947)
          | _ -> iprot#skip _t947);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str946

class system_add_column_family_args =
object (self)
  val mutable _cf_def : cfDef option = None
  method get_cf_def = _cf_def
  method grab_cf_def = match _cf_def with None->raise (Field_empty "system_add_column_family_args.cf_def") | Some _x954 -> _x954
  method set_cf_def _x954 = _cf_def <- Some _x954
  method unset_cf_def = _cf_def <- None
  method reset_cf_def = _cf_def <- None

  method copy =
      let _new = Oo.copy self in
      if _cf_def <> None then
        _new#set_cf_def self#grab_cf_def#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_column_family_args";
    (match _cf_def with 
    | None -> raise (Field_empty "system_add_column_family_args._cf_def")
    | Some _v -> 
      oprot#writeFieldBegin("cf_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_column_family_args (iprot : Protocol.t) =
  let _str957 = new system_add_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t958,_id959) = iprot#readFieldBegin in
        if _t958 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id959 with 
          | 1 -> (if _t958 = Protocol.T_STRUCT then
              _str957#set_cf_def (read_cfDef iprot)
            else
              iprot#skip _t958)
          | _ -> iprot#skip _t958);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str957

class system_add_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_add_column_family_result.success") | Some _x960 -> _x960
  method set_success _x960 = _success <- Some _x960
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_add_column_family_result.ire") | Some _x961 -> _x961
  method set_ire _x961 = _ire <- Some _x961
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_add_column_family_result.sde") | Some _x962 -> _x962
  method set_sde _x962 = _sde <- Some _x962
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_column_family_result (iprot : Protocol.t) =
  let _str965 = new system_add_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t966,_id967) = iprot#readFieldBegin in
        if _t966 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id967 with 
          | 0 -> (if _t966 = Protocol.T_STRING then
              _str965#set_success iprot#readString
            else
              iprot#skip _t966)
          | 1 -> (if _t966 = Protocol.T_STRUCT then
              _str965#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t966)
          | 2 -> (if _t966 = Protocol.T_STRUCT then
              _str965#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t966)
          | _ -> iprot#skip _t966);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str965

class system_drop_column_family_args =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "system_drop_column_family_args.column_family") | Some _x968 -> _x968
  method set_column_family _x968 = _column_family <- Some _x968
  method unset_column_family = _column_family <- None
  method reset_column_family = _column_family <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_column_family_args";
    (match _column_family with 
    | None -> raise (Field_empty "system_drop_column_family_args._column_family")
    | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_column_family_args (iprot : Protocol.t) =
  let _str971 = new system_drop_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t972,_id973) = iprot#readFieldBegin in
        if _t972 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id973 with 
          | 1 -> (if _t972 = Protocol.T_STRING then
              _str971#set_column_family iprot#readString
            else
              iprot#skip _t972)
          | _ -> iprot#skip _t972);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str971

class system_drop_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_drop_column_family_result.success") | Some _x974 -> _x974
  method set_success _x974 = _success <- Some _x974
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_drop_column_family_result.ire") | Some _x975 -> _x975
  method set_ire _x975 = _ire <- Some _x975
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_drop_column_family_result.sde") | Some _x976 -> _x976
  method set_sde _x976 = _sde <- Some _x976
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_column_family_result (iprot : Protocol.t) =
  let _str979 = new system_drop_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t980,_id981) = iprot#readFieldBegin in
        if _t980 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id981 with 
          | 0 -> (if _t980 = Protocol.T_STRING then
              _str979#set_success iprot#readString
            else
              iprot#skip _t980)
          | 1 -> (if _t980 = Protocol.T_STRUCT then
              _str979#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t980)
          | 2 -> (if _t980 = Protocol.T_STRUCT then
              _str979#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t980)
          | _ -> iprot#skip _t980);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str979

class system_add_keyspace_args =
object (self)
  val mutable _ks_def : ksDef option = None
  method get_ks_def = _ks_def
  method grab_ks_def = match _ks_def with None->raise (Field_empty "system_add_keyspace_args.ks_def") | Some _x982 -> _x982
  method set_ks_def _x982 = _ks_def <- Some _x982
  method unset_ks_def = _ks_def <- None
  method reset_ks_def = _ks_def <- None

  method copy =
      let _new = Oo.copy self in
      if _ks_def <> None then
        _new#set_ks_def self#grab_ks_def#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_keyspace_args";
    (match _ks_def with 
    | None -> raise (Field_empty "system_add_keyspace_args._ks_def")
    | Some _v -> 
      oprot#writeFieldBegin("ks_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_keyspace_args (iprot : Protocol.t) =
  let _str985 = new system_add_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t986,_id987) = iprot#readFieldBegin in
        if _t986 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id987 with 
          | 1 -> (if _t986 = Protocol.T_STRUCT then
              _str985#set_ks_def (read_ksDef iprot)
            else
              iprot#skip _t986)
          | _ -> iprot#skip _t986);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str985

class system_add_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_add_keyspace_result.success") | Some _x988 -> _x988
  method set_success _x988 = _success <- Some _x988
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_add_keyspace_result.ire") | Some _x989 -> _x989
  method set_ire _x989 = _ire <- Some _x989
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_add_keyspace_result.sde") | Some _x990 -> _x990
  method set_sde _x990 = _sde <- Some _x990
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_add_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_add_keyspace_result (iprot : Protocol.t) =
  let _str993 = new system_add_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t994,_id995) = iprot#readFieldBegin in
        if _t994 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id995 with 
          | 0 -> (if _t994 = Protocol.T_STRING then
              _str993#set_success iprot#readString
            else
              iprot#skip _t994)
          | 1 -> (if _t994 = Protocol.T_STRUCT then
              _str993#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t994)
          | 2 -> (if _t994 = Protocol.T_STRUCT then
              _str993#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t994)
          | _ -> iprot#skip _t994);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str993

class system_drop_keyspace_args =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "system_drop_keyspace_args.keyspace") | Some _x996 -> _x996
  method set_keyspace _x996 = _keyspace <- Some _x996
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_keyspace_args";
    (match _keyspace with 
    | None -> raise (Field_empty "system_drop_keyspace_args._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_keyspace_args (iprot : Protocol.t) =
  let _str999 = new system_drop_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1000,_id1001) = iprot#readFieldBegin in
        if _t1000 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1001 with 
          | 1 -> (if _t1000 = Protocol.T_STRING then
              _str999#set_keyspace iprot#readString
            else
              iprot#skip _t1000)
          | _ -> iprot#skip _t1000);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str999

class system_drop_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_drop_keyspace_result.success") | Some _x1002 -> _x1002
  method set_success _x1002 = _success <- Some _x1002
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_drop_keyspace_result.ire") | Some _x1003 -> _x1003
  method set_ire _x1003 = _ire <- Some _x1003
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_drop_keyspace_result.sde") | Some _x1004 -> _x1004
  method set_sde _x1004 = _sde <- Some _x1004
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_drop_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_drop_keyspace_result (iprot : Protocol.t) =
  let _str1007 = new system_drop_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1008,_id1009) = iprot#readFieldBegin in
        if _t1008 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1009 with 
          | 0 -> (if _t1008 = Protocol.T_STRING then
              _str1007#set_success iprot#readString
            else
              iprot#skip _t1008)
          | 1 -> (if _t1008 = Protocol.T_STRUCT then
              _str1007#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t1008)
          | 2 -> (if _t1008 = Protocol.T_STRUCT then
              _str1007#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t1008)
          | _ -> iprot#skip _t1008);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1007

class system_update_keyspace_args =
object (self)
  val mutable _ks_def : ksDef option = None
  method get_ks_def = _ks_def
  method grab_ks_def = match _ks_def with None->raise (Field_empty "system_update_keyspace_args.ks_def") | Some _x1010 -> _x1010
  method set_ks_def _x1010 = _ks_def <- Some _x1010
  method unset_ks_def = _ks_def <- None
  method reset_ks_def = _ks_def <- None

  method copy =
      let _new = Oo.copy self in
      if _ks_def <> None then
        _new#set_ks_def self#grab_ks_def#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_keyspace_args";
    (match _ks_def with 
    | None -> raise (Field_empty "system_update_keyspace_args._ks_def")
    | Some _v -> 
      oprot#writeFieldBegin("ks_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_keyspace_args (iprot : Protocol.t) =
  let _str1013 = new system_update_keyspace_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1014,_id1015) = iprot#readFieldBegin in
        if _t1014 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1015 with 
          | 1 -> (if _t1014 = Protocol.T_STRUCT then
              _str1013#set_ks_def (read_ksDef iprot)
            else
              iprot#skip _t1014)
          | _ -> iprot#skip _t1014);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1013

class system_update_keyspace_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_update_keyspace_result.success") | Some _x1016 -> _x1016
  method set_success _x1016 = _success <- Some _x1016
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_update_keyspace_result.ire") | Some _x1017 -> _x1017
  method set_ire _x1017 = _ire <- Some _x1017
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_update_keyspace_result.sde") | Some _x1018 -> _x1018
  method set_sde _x1018 = _sde <- Some _x1018
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_keyspace_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_keyspace_result (iprot : Protocol.t) =
  let _str1021 = new system_update_keyspace_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1022,_id1023) = iprot#readFieldBegin in
        if _t1022 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1023 with 
          | 0 -> (if _t1022 = Protocol.T_STRING then
              _str1021#set_success iprot#readString
            else
              iprot#skip _t1022)
          | 1 -> (if _t1022 = Protocol.T_STRUCT then
              _str1021#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t1022)
          | 2 -> (if _t1022 = Protocol.T_STRUCT then
              _str1021#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t1022)
          | _ -> iprot#skip _t1022);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1021

class system_update_column_family_args =
object (self)
  val mutable _cf_def : cfDef option = None
  method get_cf_def = _cf_def
  method grab_cf_def = match _cf_def with None->raise (Field_empty "system_update_column_family_args.cf_def") | Some _x1024 -> _x1024
  method set_cf_def _x1024 = _cf_def <- Some _x1024
  method unset_cf_def = _cf_def <- None
  method reset_cf_def = _cf_def <- None

  method copy =
      let _new = Oo.copy self in
      if _cf_def <> None then
        _new#set_cf_def self#grab_cf_def#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_column_family_args";
    (match _cf_def with 
    | None -> raise (Field_empty "system_update_column_family_args._cf_def")
    | Some _v -> 
      oprot#writeFieldBegin("cf_def",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_column_family_args (iprot : Protocol.t) =
  let _str1027 = new system_update_column_family_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1028,_id1029) = iprot#readFieldBegin in
        if _t1028 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1029 with 
          | 1 -> (if _t1028 = Protocol.T_STRUCT then
              _str1027#set_cf_def (read_cfDef iprot)
            else
              iprot#skip _t1028)
          | _ -> iprot#skip _t1028);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1027

class system_update_column_family_result =
object (self)
  val mutable _success : string option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "system_update_column_family_result.success") | Some _x1030 -> _x1030
  method set_success _x1030 = _success <- Some _x1030
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "system_update_column_family_result.ire") | Some _x1031 -> _x1031
  method set_ire _x1031 = _ire <- Some _x1031
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "system_update_column_family_result.sde") | Some _x1032 -> _x1032
  method set_sde _x1032 = _sde <- Some _x1032
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "system_update_column_family_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRING,0);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_system_update_column_family_result (iprot : Protocol.t) =
  let _str1035 = new system_update_column_family_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1036,_id1037) = iprot#readFieldBegin in
        if _t1036 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1037 with 
          | 0 -> (if _t1036 = Protocol.T_STRING then
              _str1035#set_success iprot#readString
            else
              iprot#skip _t1036)
          | 1 -> (if _t1036 = Protocol.T_STRUCT then
              _str1035#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t1036)
          | 2 -> (if _t1036 = Protocol.T_STRUCT then
              _str1035#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t1036)
          | _ -> iprot#skip _t1036);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1035

class execute_cql_query_args =
object (self)
  val mutable _query : string option = None
  method get_query = _query
  method grab_query = match _query with None->raise (Field_empty "execute_cql_query_args.query") | Some _x1038 -> _x1038
  method set_query _x1038 = _query <- Some _x1038
  method unset_query = _query <- None
  method reset_query = _query <- None

  val mutable _compression : Compression.t option = None
  method get_compression = _compression
  method grab_compression = match _compression with None->raise (Field_empty "execute_cql_query_args.compression") | Some _x1039 -> _x1039
  method set_compression _x1039 = _compression <- Some _x1039
  method unset_compression = _compression <- None
  method reset_compression = _compression <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "execute_cql_query_args";
    (match _query with 
    | None -> raise (Field_empty "execute_cql_query_args._query")
    | Some _v -> 
      oprot#writeFieldBegin("query",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _compression with 
    | None -> raise (Field_empty "execute_cql_query_args._compression")
    | Some _v -> 
      oprot#writeFieldBegin("compression",Protocol.T_I32,2);
      oprot#writeI32(Compression.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_execute_cql_query_args (iprot : Protocol.t) =
  let _str1042 = new execute_cql_query_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1043,_id1044) = iprot#readFieldBegin in
        if _t1043 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1044 with 
          | 1 -> (if _t1043 = Protocol.T_STRING then
              _str1042#set_query iprot#readString
            else
              iprot#skip _t1043)
          | 2 -> (if _t1043 = Protocol.T_I32 then
              _str1042#set_compression (Compression.of_i iprot#readI32)
            else
              iprot#skip _t1043)
          | _ -> iprot#skip _t1043);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1042

class execute_cql_query_result =
object (self)
  val mutable _success : cqlResult option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "execute_cql_query_result.success") | Some _x1045 -> _x1045
  method set_success _x1045 = _success <- Some _x1045
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "execute_cql_query_result.ire") | Some _x1046 -> _x1046
  method set_ire _x1046 = _ire <- Some _x1046
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "execute_cql_query_result.ue") | Some _x1047 -> _x1047
  method set_ue _x1047 = _ue <- Some _x1047
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "execute_cql_query_result.te") | Some _x1048 -> _x1048
  method set_te _x1048 = _te <- Some _x1048
  method unset_te = _te <- None
  method reset_te = _te <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "execute_cql_query_result.sde") | Some _x1049 -> _x1049
  method set_sde _x1049 = _sde <- Some _x1049
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "execute_cql_query_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_execute_cql_query_result (iprot : Protocol.t) =
  let _str1052 = new execute_cql_query_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1053,_id1054) = iprot#readFieldBegin in
        if _t1053 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1054 with 
          | 0 -> (if _t1053 = Protocol.T_STRUCT then
              _str1052#set_success (read_cqlResult iprot)
            else
              iprot#skip _t1053)
          | 1 -> (if _t1053 = Protocol.T_STRUCT then
              _str1052#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t1053)
          | 2 -> (if _t1053 = Protocol.T_STRUCT then
              _str1052#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t1053)
          | 3 -> (if _t1053 = Protocol.T_STRUCT then
              _str1052#set_te (read_timedOutException iprot)
            else
              iprot#skip _t1053)
          | 4 -> (if _t1053 = Protocol.T_STRUCT then
              _str1052#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t1053)
          | _ -> iprot#skip _t1053);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1052

class prepare_cql_query_args =
object (self)
  val mutable _query : string option = None
  method get_query = _query
  method grab_query = match _query with None->raise (Field_empty "prepare_cql_query_args.query") | Some _x1055 -> _x1055
  method set_query _x1055 = _query <- Some _x1055
  method unset_query = _query <- None
  method reset_query = _query <- None

  val mutable _compression : Compression.t option = None
  method get_compression = _compression
  method grab_compression = match _compression with None->raise (Field_empty "prepare_cql_query_args.compression") | Some _x1056 -> _x1056
  method set_compression _x1056 = _compression <- Some _x1056
  method unset_compression = _compression <- None
  method reset_compression = _compression <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "prepare_cql_query_args";
    (match _query with 
    | None -> raise (Field_empty "prepare_cql_query_args._query")
    | Some _v -> 
      oprot#writeFieldBegin("query",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _compression with 
    | None -> raise (Field_empty "prepare_cql_query_args._compression")
    | Some _v -> 
      oprot#writeFieldBegin("compression",Protocol.T_I32,2);
      oprot#writeI32(Compression.to_i _v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_prepare_cql_query_args (iprot : Protocol.t) =
  let _str1059 = new prepare_cql_query_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1060,_id1061) = iprot#readFieldBegin in
        if _t1060 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1061 with 
          | 1 -> (if _t1060 = Protocol.T_STRING then
              _str1059#set_query iprot#readString
            else
              iprot#skip _t1060)
          | 2 -> (if _t1060 = Protocol.T_I32 then
              _str1059#set_compression (Compression.of_i iprot#readI32)
            else
              iprot#skip _t1060)
          | _ -> iprot#skip _t1060);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1059

class prepare_cql_query_result =
object (self)
  val mutable _success : cqlPreparedResult option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "prepare_cql_query_result.success") | Some _x1062 -> _x1062
  method set_success _x1062 = _success <- Some _x1062
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "prepare_cql_query_result.ire") | Some _x1063 -> _x1063
  method set_ire _x1063 = _ire <- Some _x1063
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "prepare_cql_query_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_prepare_cql_query_result (iprot : Protocol.t) =
  let _str1066 = new prepare_cql_query_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1067,_id1068) = iprot#readFieldBegin in
        if _t1067 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1068 with 
          | 0 -> (if _t1067 = Protocol.T_STRUCT then
              _str1066#set_success (read_cqlPreparedResult iprot)
            else
              iprot#skip _t1067)
          | 1 -> (if _t1067 = Protocol.T_STRUCT then
              _str1066#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t1067)
          | _ -> iprot#skip _t1067);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1066

class execute_prepared_cql_query_args =
object (self)
  val mutable _itemId : Int32.t option = None
  method get_itemId = _itemId
  method grab_itemId = match _itemId with None->raise (Field_empty "execute_prepared_cql_query_args.itemId") | Some _x1069 -> _x1069
  method set_itemId _x1069 = _itemId <- Some _x1069
  method unset_itemId = _itemId <- None
  method reset_itemId = _itemId <- None

  val mutable _values : string list option = None
  method get_values = _values
  method grab_values = match _values with None->raise (Field_empty "execute_prepared_cql_query_args.values") | Some _x1070 -> _x1070
  method set_values _x1070 = _values <- Some _x1070
  method unset_values = _values <- None
  method reset_values = _values <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "execute_prepared_cql_query_args";
    (match _itemId with 
    | None -> raise (Field_empty "execute_prepared_cql_query_args._itemId")
    | Some _v -> 
      oprot#writeFieldBegin("itemId",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _values with 
    | None -> raise (Field_empty "execute_prepared_cql_query_args._values")
    | Some _v -> 
      oprot#writeFieldBegin("values",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter1073 ->         oprot#writeString(_iter1073);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_execute_prepared_cql_query_args (iprot : Protocol.t) =
  let _str1074 = new execute_prepared_cql_query_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1075,_id1076) = iprot#readFieldBegin in
        if _t1075 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1076 with 
          | 1 -> (if _t1075 = Protocol.T_I32 then
              _str1074#set_itemId iprot#readI32
            else
              iprot#skip _t1075)
          | 2 -> (if _t1075 = Protocol.T_LIST then
              _str1074#set_values 
                (let (_etype1080,_size1077) = iprot#readListBegin in
                  let _con1081 = (Array.to_list (Array.init _size1077 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con1081)
            else
              iprot#skip _t1075)
          | _ -> iprot#skip _t1075);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1074

class execute_prepared_cql_query_result =
object (self)
  val mutable _success : cqlResult option = None
  method get_success = _success
  method grab_success = match _success with None->raise (Field_empty "execute_prepared_cql_query_result.success") | Some _x1082 -> _x1082
  method set_success _x1082 = _success <- Some _x1082
  method unset_success = _success <- None
  method reset_success = _success <- None

  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "execute_prepared_cql_query_result.ire") | Some _x1083 -> _x1083
  method set_ire _x1083 = _ire <- Some _x1083
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  val mutable _ue : unavailableException option = None
  method get_ue = _ue
  method grab_ue = match _ue with None->raise (Field_empty "execute_prepared_cql_query_result.ue") | Some _x1084 -> _x1084
  method set_ue _x1084 = _ue <- Some _x1084
  method unset_ue = _ue <- None
  method reset_ue = _ue <- None

  val mutable _te : timedOutException option = None
  method get_te = _te
  method grab_te = match _te with None->raise (Field_empty "execute_prepared_cql_query_result.te") | Some _x1085 -> _x1085
  method set_te _x1085 = _te <- Some _x1085
  method unset_te = _te <- None
  method reset_te = _te <- None

  val mutable _sde : schemaDisagreementException option = None
  method get_sde = _sde
  method grab_sde = match _sde with None->raise (Field_empty "execute_prepared_cql_query_result.sde") | Some _x1086 -> _x1086
  method set_sde _x1086 = _sde <- Some _x1086
  method unset_sde = _sde <- None
  method reset_sde = _sde <- None

  method copy =
      let _new = Oo.copy self in
      if _success <> None then
        _new#set_success self#grab_success#copy;
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
      if _ue <> None then
        _new#set_ue self#grab_ue#copy;
      if _te <> None then
        _new#set_te self#grab_te#copy;
      if _sde <> None then
        _new#set_sde self#grab_sde#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "execute_prepared_cql_query_result";
    (match _success with None -> () | Some _v -> 
      oprot#writeFieldBegin("success",Protocol.T_STRUCT,0);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _ue with None -> () | Some _v -> 
      oprot#writeFieldBegin("ue",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _te with None -> () | Some _v -> 
      oprot#writeFieldBegin("te",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _sde with None -> () | Some _v -> 
      oprot#writeFieldBegin("sde",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_execute_prepared_cql_query_result (iprot : Protocol.t) =
  let _str1089 = new execute_prepared_cql_query_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1090,_id1091) = iprot#readFieldBegin in
        if _t1090 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1091 with 
          | 0 -> (if _t1090 = Protocol.T_STRUCT then
              _str1089#set_success (read_cqlResult iprot)
            else
              iprot#skip _t1090)
          | 1 -> (if _t1090 = Protocol.T_STRUCT then
              _str1089#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t1090)
          | 2 -> (if _t1090 = Protocol.T_STRUCT then
              _str1089#set_ue (read_unavailableException iprot)
            else
              iprot#skip _t1090)
          | 3 -> (if _t1090 = Protocol.T_STRUCT then
              _str1089#set_te (read_timedOutException iprot)
            else
              iprot#skip _t1090)
          | 4 -> (if _t1090 = Protocol.T_STRUCT then
              _str1089#set_sde (read_schemaDisagreementException iprot)
            else
              iprot#skip _t1090)
          | _ -> iprot#skip _t1090);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1089

class set_cql_version_args =
object (self)
  val mutable _version : string option = None
  method get_version = _version
  method grab_version = match _version with None->raise (Field_empty "set_cql_version_args.version") | Some _x1092 -> _x1092
  method set_version _x1092 = _version <- Some _x1092
  method unset_version = _version <- None
  method reset_version = _version <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_cql_version_args";
    (match _version with 
    | None -> raise (Field_empty "set_cql_version_args._version")
    | Some _v -> 
      oprot#writeFieldBegin("version",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_cql_version_args (iprot : Protocol.t) =
  let _str1095 = new set_cql_version_args in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1096,_id1097) = iprot#readFieldBegin in
        if _t1096 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1097 with 
          | 1 -> (if _t1096 = Protocol.T_STRING then
              _str1095#set_version iprot#readString
            else
              iprot#skip _t1096)
          | _ -> iprot#skip _t1096);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1095

class set_cql_version_result =
object (self)
  val mutable _ire : invalidRequestException option = None
  method get_ire = _ire
  method grab_ire = match _ire with None->raise (Field_empty "set_cql_version_result.ire") | Some _x1098 -> _x1098
  method set_ire _x1098 = _ire <- Some _x1098
  method unset_ire = _ire <- None
  method reset_ire = _ire <- None

  method copy =
      let _new = Oo.copy self in
      if _ire <> None then
        _new#set_ire self#grab_ire#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "set_cql_version_result";
    (match _ire with None -> () | Some _v -> 
      oprot#writeFieldBegin("ire",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_set_cql_version_result (iprot : Protocol.t) =
  let _str1101 = new set_cql_version_result in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t1102,_id1103) = iprot#readFieldBegin in
        if _t1102 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id1103 with 
          | 1 -> (if _t1102 = Protocol.T_STRUCT then
              _str1101#set_ire (read_invalidRequestException iprot)
            else
              iprot#skip _t1102)
          | _ -> iprot#skip _t1102);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str1101

class virtual iface =
object (self)
  method virtual login : authenticationRequest option -> unit
  method virtual set_keyspace : string option -> unit
  method virtual get : string option -> columnPath option -> ConsistencyLevel.t option -> columnOrSuperColumn
  method virtual get_slice : string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> columnOrSuperColumn list
  method virtual get_count : string option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> Int32.t
  method virtual multiget_slice : string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,columnOrSuperColumn list) Hashtbl.t
  method virtual multiget_count : string list option -> columnParent option -> slicePredicate option -> ConsistencyLevel.t option -> (string,Int32.t) Hashtbl.t
  method virtual get_range_slices : columnParent option -> slicePredicate option -> keyRange option -> ConsistencyLevel.t option -> keySlice list
  method virtual get_paged_slice : string option -> keyRange option -> string option -> ConsistencyLevel.t option -> keySlice list
  method virtual get_indexed_slices : columnParent option -> indexClause option -> slicePredicate option -> ConsistencyLevel.t option -> keySlice list
  method virtual insert : string option -> columnParent option -> column option -> ConsistencyLevel.t option -> unit
  method virtual add : string option -> columnParent option -> counterColumn option -> ConsistencyLevel.t option -> unit
  method virtual remove : string option -> columnPath option -> Int64.t option -> ConsistencyLevel.t option -> unit
  method virtual remove_counter : string option -> columnPath option -> ConsistencyLevel.t option -> unit
  method virtual batch_mutate : (string,(string,mutation list) Hashtbl.t) Hashtbl.t option -> ConsistencyLevel.t option -> unit
  method virtual truncate : string option -> unit
  method virtual describe_schema_versions : (string,string list) Hashtbl.t
  method virtual describe_keyspaces : ksDef list
  method virtual describe_cluster_name : string
  method virtual describe_version : string
  method virtual describe_ring : string option -> tokenRange list
  method virtual describe_token_map : (string,string) Hashtbl.t
  method virtual describe_partitioner : string
  method virtual describe_snitch : string
  method virtual describe_keyspace : string option -> ksDef
  method virtual describe_splits : string option -> string option -> string option -> Int32.t option -> string list
  method virtual system_add_column_family : cfDef option -> string
  method virtual system_drop_column_family : string option -> string
  method virtual system_add_keyspace : ksDef option -> string
  method virtual system_drop_keyspace : string option -> string
  method virtual system_update_keyspace : ksDef option -> string
  method virtual system_update_column_family : cfDef option -> string
  method virtual execute_cql_query : string option -> Compression.t option -> cqlResult
  method virtual prepare_cql_query : string option -> Compression.t option -> cqlPreparedResult
  method virtual execute_prepared_cql_query : Int32.t option -> string list option -> cqlResult
  method virtual set_cql_version : string option -> unit
end

class client (iprot : Protocol.t) (oprot : Protocol.t) =
object (self)
  val mutable seqid = 0
  method login auth_request = 
    self#send_login auth_request;
    self#recv_login
  method private send_login auth_request = 
    oprot#writeMessageBegin ("login", Protocol.CALL, seqid);
    let args = new login_args in
      args#set_auth_request auth_request;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_login  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_login_result iprot in
        iprot#readMessageEnd;
        (match result#get_authnx with None -> () | Some _v ->
          raise (AuthenticationException _v));
        (match result#get_authzx with None -> () | Some _v ->
          raise (AuthorizationException _v));
        ()
  method set_keyspace keyspace = 
    self#send_set_keyspace keyspace;
    self#recv_set_keyspace
  method private send_set_keyspace keyspace = 
    oprot#writeMessageBegin ("set_keyspace", Protocol.CALL, seqid);
    let args = new set_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_set_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_set_keyspace_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        ()
  method get key column_path consistency_level = 
    self#send_get key column_path consistency_level;
    self#recv_get
  method private send_get key column_path consistency_level = 
    oprot#writeMessageBegin ("get", Protocol.CALL, seqid);
    let args = new get_args in
      args#set_key key;
      args#set_column_path column_path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get failed: unknown result")))
  method get_slice key column_parent predicate consistency_level = 
    self#send_get_slice key column_parent predicate consistency_level;
    self#recv_get_slice
  method private send_get_slice key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_slice", Protocol.CALL, seqid);
    let args = new get_slice_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_slice failed: unknown result")))
  method get_count key column_parent predicate consistency_level = 
    self#send_get_count key column_parent predicate consistency_level;
    self#recv_get_count
  method private send_get_count key column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("get_count", Protocol.CALL, seqid);
    let args = new get_count_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_count failed: unknown result")))
  method multiget_slice keys column_parent predicate consistency_level = 
    self#send_multiget_slice keys column_parent predicate consistency_level;
    self#recv_multiget_slice
  method private send_multiget_slice keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_slice", Protocol.CALL, seqid);
    let args = new multiget_slice_args in
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_slice failed: unknown result")))
  method multiget_count keys column_parent predicate consistency_level = 
    self#send_multiget_count keys column_parent predicate consistency_level;
    self#recv_multiget_count
  method private send_multiget_count keys column_parent predicate consistency_level = 
    oprot#writeMessageBegin ("multiget_count", Protocol.CALL, seqid);
    let args = new multiget_count_args in
      args#set_keys keys;
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_multiget_count  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_multiget_count_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "multiget_count failed: unknown result")))
  method get_range_slices column_parent predicate range consistency_level = 
    self#send_get_range_slices column_parent predicate range consistency_level;
    self#recv_get_range_slices
  method private send_get_range_slices column_parent predicate range consistency_level = 
    oprot#writeMessageBegin ("get_range_slices", Protocol.CALL, seqid);
    let args = new get_range_slices_args in
      args#set_column_parent column_parent;
      args#set_predicate predicate;
      args#set_range range;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_range_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_range_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_range_slices failed: unknown result")))
  method get_paged_slice column_family range start_column consistency_level = 
    self#send_get_paged_slice column_family range start_column consistency_level;
    self#recv_get_paged_slice
  method private send_get_paged_slice column_family range start_column consistency_level = 
    oprot#writeMessageBegin ("get_paged_slice", Protocol.CALL, seqid);
    let args = new get_paged_slice_args in
      args#set_column_family column_family;
      args#set_range range;
      args#set_start_column start_column;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_paged_slice  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_paged_slice_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_paged_slice failed: unknown result")))
  method get_indexed_slices column_parent index_clause column_predicate consistency_level = 
    self#send_get_indexed_slices column_parent index_clause column_predicate consistency_level;
    self#recv_get_indexed_slices
  method private send_get_indexed_slices column_parent index_clause column_predicate consistency_level = 
    oprot#writeMessageBegin ("get_indexed_slices", Protocol.CALL, seqid);
    let args = new get_indexed_slices_args in
      args#set_column_parent column_parent;
      args#set_index_clause index_clause;
      args#set_column_predicate column_predicate;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_get_indexed_slices  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_get_indexed_slices_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "get_indexed_slices failed: unknown result")))
  method insert key column_parent column consistency_level = 
    self#send_insert key column_parent column consistency_level;
    self#recv_insert
  method private send_insert key column_parent column consistency_level = 
    oprot#writeMessageBegin ("insert", Protocol.CALL, seqid);
    let args = new insert_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_column column;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_insert  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_insert_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method add key column_parent column consistency_level = 
    self#send_add key column_parent column consistency_level;
    self#recv_add
  method private send_add key column_parent column consistency_level = 
    oprot#writeMessageBegin ("add", Protocol.CALL, seqid);
    let args = new add_args in
      args#set_key key;
      args#set_column_parent column_parent;
      args#set_column column;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_add  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_add_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method remove key column_path timestamp consistency_level = 
    self#send_remove key column_path timestamp consistency_level;
    self#recv_remove
  method private send_remove key column_path timestamp consistency_level = 
    oprot#writeMessageBegin ("remove", Protocol.CALL, seqid);
    let args = new remove_args in
      args#set_key key;
      args#set_column_path column_path;
      args#set_timestamp timestamp;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_remove  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_remove_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method remove_counter key path consistency_level = 
    self#send_remove_counter key path consistency_level;
    self#recv_remove_counter
  method private send_remove_counter key path consistency_level = 
    oprot#writeMessageBegin ("remove_counter", Protocol.CALL, seqid);
    let args = new remove_counter_args in
      args#set_key key;
      args#set_path path;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_remove_counter  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_remove_counter_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method batch_mutate mutation_map consistency_level = 
    self#send_batch_mutate mutation_map consistency_level;
    self#recv_batch_mutate
  method private send_batch_mutate mutation_map consistency_level = 
    oprot#writeMessageBegin ("batch_mutate", Protocol.CALL, seqid);
    let args = new batch_mutate_args in
      args#set_mutation_map mutation_map;
      args#set_consistency_level consistency_level;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_batch_mutate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_batch_mutate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method truncate cfname = 
    self#send_truncate cfname;
    self#recv_truncate
  method private send_truncate cfname = 
    oprot#writeMessageBegin ("truncate", Protocol.CALL, seqid);
    let args = new truncate_args in
      args#set_cfname cfname;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_truncate  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_truncate_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        (match result#get_ue with None -> () | Some _v ->
          raise (UnavailableException _v));
        (match result#get_te with None -> () | Some _v ->
          raise (TimedOutException _v));
        ()
  method describe_schema_versions  = 
    self#send_describe_schema_versions;
    self#recv_describe_schema_versions
  method private send_describe_schema_versions  = 
    oprot#writeMessageBegin ("describe_schema_versions", Protocol.CALL, seqid);
    let args = new describe_schema_versions_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_schema_versions  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_schema_versions_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_schema_versions failed: unknown result")))
  method describe_keyspaces  = 
    self#send_describe_keyspaces;
    self#recv_describe_keyspaces
  method private send_describe_keyspaces  = 
    oprot#writeMessageBegin ("describe_keyspaces", Protocol.CALL, seqid);
    let args = new describe_keyspaces_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspaces  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspaces_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspaces failed: unknown result")))
  method describe_cluster_name  = 
    self#send_describe_cluster_name;
    self#recv_describe_cluster_name
  method private send_describe_cluster_name  = 
    oprot#writeMessageBegin ("describe_cluster_name", Protocol.CALL, seqid);
    let args = new describe_cluster_name_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_cluster_name  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_cluster_name_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_cluster_name failed: unknown result")))
  method describe_version  = 
    self#send_describe_version;
    self#recv_describe_version
  method private send_describe_version  = 
    oprot#writeMessageBegin ("describe_version", Protocol.CALL, seqid);
    let args = new describe_version_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_version  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_version_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_version failed: unknown result")))
  method describe_ring keyspace = 
    self#send_describe_ring keyspace;
    self#recv_describe_ring
  method private send_describe_ring keyspace = 
    oprot#writeMessageBegin ("describe_ring", Protocol.CALL, seqid);
    let args = new describe_ring_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_ring  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_ring_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_ring failed: unknown result")))
  method describe_token_map  = 
    self#send_describe_token_map;
    self#recv_describe_token_map
  method private send_describe_token_map  = 
    oprot#writeMessageBegin ("describe_token_map", Protocol.CALL, seqid);
    let args = new describe_token_map_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_token_map  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_token_map_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_token_map failed: unknown result")))
  method describe_partitioner  = 
    self#send_describe_partitioner;
    self#recv_describe_partitioner
  method private send_describe_partitioner  = 
    oprot#writeMessageBegin ("describe_partitioner", Protocol.CALL, seqid);
    let args = new describe_partitioner_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_partitioner  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_partitioner_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_partitioner failed: unknown result")))
  method describe_snitch  = 
    self#send_describe_snitch;
    self#recv_describe_snitch
  method private send_describe_snitch  = 
    oprot#writeMessageBegin ("describe_snitch", Protocol.CALL, seqid);
    let args = new describe_snitch_args in
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_snitch  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_snitch_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_snitch failed: unknown result")))
  method describe_keyspace keyspace = 
    self#send_describe_keyspace keyspace;
    self#recv_describe_keyspace
  method private send_describe_keyspace keyspace = 
    oprot#writeMessageBegin ("describe_keyspace", Protocol.CALL, seqid);
    let args = new describe_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_nfe with None -> () | Some _v ->
            raise (NotFoundException _v));
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_keyspace failed: unknown result")))
  method describe_splits cfName start_token end_token keys_per_split = 
    self#send_describe_splits cfName start_token end_token keys_per_split;
    self#recv_describe_splits
  method private send_describe_splits cfName start_token end_token keys_per_split = 
    oprot#writeMessageBegin ("describe_splits", Protocol.CALL, seqid);
    let args = new describe_splits_args in
      args#set_cfName cfName;
      args#set_start_token start_token;
      args#set_end_token end_token;
      args#set_keys_per_split keys_per_split;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_describe_splits  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_describe_splits_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "describe_splits failed: unknown result")))
  method system_add_column_family cf_def = 
    self#send_system_add_column_family cf_def;
    self#recv_system_add_column_family
  method private send_system_add_column_family cf_def = 
    oprot#writeMessageBegin ("system_add_column_family", Protocol.CALL, seqid);
    let args = new system_add_column_family_args in
      args#set_cf_def cf_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_add_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_add_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_add_column_family failed: unknown result")))
  method system_drop_column_family column_family = 
    self#send_system_drop_column_family column_family;
    self#recv_system_drop_column_family
  method private send_system_drop_column_family column_family = 
    oprot#writeMessageBegin ("system_drop_column_family", Protocol.CALL, seqid);
    let args = new system_drop_column_family_args in
      args#set_column_family column_family;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_drop_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_drop_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_drop_column_family failed: unknown result")))
  method system_add_keyspace ks_def = 
    self#send_system_add_keyspace ks_def;
    self#recv_system_add_keyspace
  method private send_system_add_keyspace ks_def = 
    oprot#writeMessageBegin ("system_add_keyspace", Protocol.CALL, seqid);
    let args = new system_add_keyspace_args in
      args#set_ks_def ks_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_add_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_add_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_add_keyspace failed: unknown result")))
  method system_drop_keyspace keyspace = 
    self#send_system_drop_keyspace keyspace;
    self#recv_system_drop_keyspace
  method private send_system_drop_keyspace keyspace = 
    oprot#writeMessageBegin ("system_drop_keyspace", Protocol.CALL, seqid);
    let args = new system_drop_keyspace_args in
      args#set_keyspace keyspace;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_drop_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_drop_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_drop_keyspace failed: unknown result")))
  method system_update_keyspace ks_def = 
    self#send_system_update_keyspace ks_def;
    self#recv_system_update_keyspace
  method private send_system_update_keyspace ks_def = 
    oprot#writeMessageBegin ("system_update_keyspace", Protocol.CALL, seqid);
    let args = new system_update_keyspace_args in
      args#set_ks_def ks_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_update_keyspace  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_update_keyspace_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_update_keyspace failed: unknown result")))
  method system_update_column_family cf_def = 
    self#send_system_update_column_family cf_def;
    self#recv_system_update_column_family
  method private send_system_update_column_family cf_def = 
    oprot#writeMessageBegin ("system_update_column_family", Protocol.CALL, seqid);
    let args = new system_update_column_family_args in
      args#set_cf_def cf_def;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_system_update_column_family  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_system_update_column_family_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "system_update_column_family failed: unknown result")))
  method execute_cql_query query compression = 
    self#send_execute_cql_query query compression;
    self#recv_execute_cql_query
  method private send_execute_cql_query query compression = 
    oprot#writeMessageBegin ("execute_cql_query", Protocol.CALL, seqid);
    let args = new execute_cql_query_args in
      args#set_query query;
      args#set_compression compression;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_execute_cql_query  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_execute_cql_query_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "execute_cql_query failed: unknown result")))
  method prepare_cql_query query compression = 
    self#send_prepare_cql_query query compression;
    self#recv_prepare_cql_query
  method private send_prepare_cql_query query compression = 
    oprot#writeMessageBegin ("prepare_cql_query", Protocol.CALL, seqid);
    let args = new prepare_cql_query_args in
      args#set_query query;
      args#set_compression compression;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_prepare_cql_query  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_prepare_cql_query_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "prepare_cql_query failed: unknown result")))
  method execute_prepared_cql_query itemId values = 
    self#send_execute_prepared_cql_query itemId values;
    self#recv_execute_prepared_cql_query
  method private send_execute_prepared_cql_query itemId values = 
    oprot#writeMessageBegin ("execute_prepared_cql_query", Protocol.CALL, seqid);
    let args = new execute_prepared_cql_query_args in
      args#set_itemId itemId;
      args#set_values values;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_execute_prepared_cql_query  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_execute_prepared_cql_query_result iprot in
        iprot#readMessageEnd;
        match result#get_success with Some v -> v | None -> (
          (match result#get_ire with None -> () | Some _v ->
            raise (InvalidRequestException _v));
          (match result#get_ue with None -> () | Some _v ->
            raise (UnavailableException _v));
          (match result#get_te with None -> () | Some _v ->
            raise (TimedOutException _v));
          (match result#get_sde with None -> () | Some _v ->
            raise (SchemaDisagreementException _v));
          raise (Application_Exn.E (Application_Exn.create Application_Exn.MISSING_RESULT "execute_prepared_cql_query failed: unknown result")))
  method set_cql_version version = 
    self#send_set_cql_version version;
    self#recv_set_cql_version
  method private send_set_cql_version version = 
    oprot#writeMessageBegin ("set_cql_version", Protocol.CALL, seqid);
    let args = new set_cql_version_args in
      args#set_version version;
      args#write oprot;
      oprot#writeMessageEnd;
      oprot#getTransport#flush
  method private recv_set_cql_version  =
    let (fname, mtype, rseqid) = iprot#readMessageBegin in
      (if mtype = Protocol.EXCEPTION then
        let x = Application_Exn.read iprot in
          (iprot#readMessageEnd;           raise (Application_Exn.E x))
      else ());
      let result = read_set_cql_version_result iprot in
        iprot#readMessageEnd;
        (match result#get_ire with None -> () | Some _v ->
          raise (InvalidRequestException _v));
        ()
end

class processor (handler : iface) =
object (self)
  inherit Processor.t

  val processMap = Hashtbl.create 36
  method process iprot oprot =
    let (name, typ, seqid)  = iprot#readMessageBegin in
      if Hashtbl.mem processMap name then
        (Hashtbl.find processMap name) (seqid, iprot, oprot)
      else (
        iprot#skip(Protocol.T_STRUCT);
        iprot#readMessageEnd;
        let x = Application_Exn.create Application_Exn.UNKNOWN_METHOD ("Unknown function "^name) in
          oprot#writeMessageBegin(name, Protocol.EXCEPTION, seqid);
          x#write oprot;
          oprot#writeMessageEnd;
          oprot#getTransport#flush
      );
      true
  method private process_login (seqid, iprot, oprot) =
    let args = read_login_args iprot in
      iprot#readMessageEnd;
      let result = new login_result in
        (try
          (handler#login args#get_auth_request);
        with
          | AuthenticationException authnx -> 
              result#set_authnx authnx
          | AuthorizationException authzx -> 
              result#set_authzx authzx
        );
        oprot#writeMessageBegin ("login", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_set_keyspace (seqid, iprot, oprot) =
    let args = read_set_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new set_keyspace_result in
        (try
          (handler#set_keyspace args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("set_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get (seqid, iprot, oprot) =
    let args = read_get_args iprot in
      iprot#readMessageEnd;
      let result = new get_result in
        (try
          result#set_success (handler#get args#get_key args#get_column_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_slice (seqid, iprot, oprot) =
    let args = read_get_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_slice_result in
        (try
          result#set_success (handler#get_slice args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_count (seqid, iprot, oprot) =
    let args = read_get_count_args iprot in
      iprot#readMessageEnd;
      let result = new get_count_result in
        (try
          result#set_success (handler#get_count args#get_key args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_slice (seqid, iprot, oprot) =
    let args = read_multiget_slice_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_slice_result in
        (try
          result#set_success (handler#multiget_slice args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_multiget_count (seqid, iprot, oprot) =
    let args = read_multiget_count_args iprot in
      iprot#readMessageEnd;
      let result = new multiget_count_result in
        (try
          result#set_success (handler#multiget_count args#get_keys args#get_column_parent args#get_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("multiget_count", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_range_slices (seqid, iprot, oprot) =
    let args = read_get_range_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_range_slices_result in
        (try
          result#set_success (handler#get_range_slices args#get_column_parent args#get_predicate args#get_range args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_range_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_paged_slice (seqid, iprot, oprot) =
    let args = read_get_paged_slice_args iprot in
      iprot#readMessageEnd;
      let result = new get_paged_slice_result in
        (try
          result#set_success (handler#get_paged_slice args#get_column_family args#get_range args#get_start_column args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_paged_slice", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_get_indexed_slices (seqid, iprot, oprot) =
    let args = read_get_indexed_slices_args iprot in
      iprot#readMessageEnd;
      let result = new get_indexed_slices_result in
        (try
          result#set_success (handler#get_indexed_slices args#get_column_parent args#get_index_clause args#get_column_predicate args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("get_indexed_slices", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_insert (seqid, iprot, oprot) =
    let args = read_insert_args iprot in
      iprot#readMessageEnd;
      let result = new insert_result in
        (try
          (handler#insert args#get_key args#get_column_parent args#get_column args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("insert", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_add (seqid, iprot, oprot) =
    let args = read_add_args iprot in
      iprot#readMessageEnd;
      let result = new add_result in
        (try
          (handler#add args#get_key args#get_column_parent args#get_column args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("add", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove (seqid, iprot, oprot) =
    let args = read_remove_args iprot in
      iprot#readMessageEnd;
      let result = new remove_result in
        (try
          (handler#remove args#get_key args#get_column_path args#get_timestamp args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("remove", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_remove_counter (seqid, iprot, oprot) =
    let args = read_remove_counter_args iprot in
      iprot#readMessageEnd;
      let result = new remove_counter_result in
        (try
          (handler#remove_counter args#get_key args#get_path args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("remove_counter", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_batch_mutate (seqid, iprot, oprot) =
    let args = read_batch_mutate_args iprot in
      iprot#readMessageEnd;
      let result = new batch_mutate_result in
        (try
          (handler#batch_mutate args#get_mutation_map args#get_consistency_level);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("batch_mutate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_truncate (seqid, iprot, oprot) =
    let args = read_truncate_args iprot in
      iprot#readMessageEnd;
      let result = new truncate_result in
        (try
          (handler#truncate args#get_cfname);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
        );
        oprot#writeMessageBegin ("truncate", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_schema_versions (seqid, iprot, oprot) =
    let _ = read_describe_schema_versions_args iprot in
      iprot#readMessageEnd;
      let result = new describe_schema_versions_result in
        (try
          result#set_success (handler#describe_schema_versions);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_schema_versions", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspaces (seqid, iprot, oprot) =
    let _ = read_describe_keyspaces_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspaces_result in
        (try
          result#set_success (handler#describe_keyspaces);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_keyspaces", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_cluster_name (seqid, iprot, oprot) =
    let _ = read_describe_cluster_name_args iprot in
      iprot#readMessageEnd;
      let result = new describe_cluster_name_result in
        result#set_success (handler#describe_cluster_name);
        oprot#writeMessageBegin ("describe_cluster_name", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_version (seqid, iprot, oprot) =
    let _ = read_describe_version_args iprot in
      iprot#readMessageEnd;
      let result = new describe_version_result in
        result#set_success (handler#describe_version);
        oprot#writeMessageBegin ("describe_version", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_ring (seqid, iprot, oprot) =
    let args = read_describe_ring_args iprot in
      iprot#readMessageEnd;
      let result = new describe_ring_result in
        (try
          result#set_success (handler#describe_ring args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_ring", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_token_map (seqid, iprot, oprot) =
    let _ = read_describe_token_map_args iprot in
      iprot#readMessageEnd;
      let result = new describe_token_map_result in
        (try
          result#set_success (handler#describe_token_map);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_token_map", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_partitioner (seqid, iprot, oprot) =
    let _ = read_describe_partitioner_args iprot in
      iprot#readMessageEnd;
      let result = new describe_partitioner_result in
        result#set_success (handler#describe_partitioner);
        oprot#writeMessageBegin ("describe_partitioner", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_snitch (seqid, iprot, oprot) =
    let _ = read_describe_snitch_args iprot in
      iprot#readMessageEnd;
      let result = new describe_snitch_result in
        result#set_success (handler#describe_snitch);
        oprot#writeMessageBegin ("describe_snitch", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_keyspace (seqid, iprot, oprot) =
    let args = read_describe_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new describe_keyspace_result in
        (try
          result#set_success (handler#describe_keyspace args#get_keyspace);
        with
          | NotFoundException nfe -> 
              result#set_nfe nfe
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_describe_splits (seqid, iprot, oprot) =
    let args = read_describe_splits_args iprot in
      iprot#readMessageEnd;
      let result = new describe_splits_result in
        (try
          result#set_success (handler#describe_splits args#get_cfName args#get_start_token args#get_end_token args#get_keys_per_split);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("describe_splits", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_add_column_family (seqid, iprot, oprot) =
    let args = read_system_add_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_add_column_family_result in
        (try
          result#set_success (handler#system_add_column_family args#get_cf_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_add_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_drop_column_family (seqid, iprot, oprot) =
    let args = read_system_drop_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_drop_column_family_result in
        (try
          result#set_success (handler#system_drop_column_family args#get_column_family);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_drop_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_add_keyspace (seqid, iprot, oprot) =
    let args = read_system_add_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_add_keyspace_result in
        (try
          result#set_success (handler#system_add_keyspace args#get_ks_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_add_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_drop_keyspace (seqid, iprot, oprot) =
    let args = read_system_drop_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_drop_keyspace_result in
        (try
          result#set_success (handler#system_drop_keyspace args#get_keyspace);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_drop_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_update_keyspace (seqid, iprot, oprot) =
    let args = read_system_update_keyspace_args iprot in
      iprot#readMessageEnd;
      let result = new system_update_keyspace_result in
        (try
          result#set_success (handler#system_update_keyspace args#get_ks_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_update_keyspace", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_system_update_column_family (seqid, iprot, oprot) =
    let args = read_system_update_column_family_args iprot in
      iprot#readMessageEnd;
      let result = new system_update_column_family_result in
        (try
          result#set_success (handler#system_update_column_family args#get_cf_def);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("system_update_column_family", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_execute_cql_query (seqid, iprot, oprot) =
    let args = read_execute_cql_query_args iprot in
      iprot#readMessageEnd;
      let result = new execute_cql_query_result in
        (try
          result#set_success (handler#execute_cql_query args#get_query args#get_compression);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("execute_cql_query", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_prepare_cql_query (seqid, iprot, oprot) =
    let args = read_prepare_cql_query_args iprot in
      iprot#readMessageEnd;
      let result = new prepare_cql_query_result in
        (try
          result#set_success (handler#prepare_cql_query args#get_query args#get_compression);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("prepare_cql_query", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_execute_prepared_cql_query (seqid, iprot, oprot) =
    let args = read_execute_prepared_cql_query_args iprot in
      iprot#readMessageEnd;
      let result = new execute_prepared_cql_query_result in
        (try
          result#set_success (handler#execute_prepared_cql_query args#get_itemId args#get_values);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
          | UnavailableException ue -> 
              result#set_ue ue
          | TimedOutException te -> 
              result#set_te te
          | SchemaDisagreementException sde -> 
              result#set_sde sde
        );
        oprot#writeMessageBegin ("execute_prepared_cql_query", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  method private process_set_cql_version (seqid, iprot, oprot) =
    let args = read_set_cql_version_args iprot in
      iprot#readMessageEnd;
      let result = new set_cql_version_result in
        (try
          (handler#set_cql_version args#get_version);
        with
          | InvalidRequestException ire -> 
              result#set_ire ire
        );
        oprot#writeMessageBegin ("set_cql_version", Protocol.REPLY, seqid);
        result#write oprot;
        oprot#writeMessageEnd;
        oprot#getTransport#flush
  initializer
    Hashtbl.add processMap "login" self#process_login;
    Hashtbl.add processMap "set_keyspace" self#process_set_keyspace;
    Hashtbl.add processMap "get" self#process_get;
    Hashtbl.add processMap "get_slice" self#process_get_slice;
    Hashtbl.add processMap "get_count" self#process_get_count;
    Hashtbl.add processMap "multiget_slice" self#process_multiget_slice;
    Hashtbl.add processMap "multiget_count" self#process_multiget_count;
    Hashtbl.add processMap "get_range_slices" self#process_get_range_slices;
    Hashtbl.add processMap "get_paged_slice" self#process_get_paged_slice;
    Hashtbl.add processMap "get_indexed_slices" self#process_get_indexed_slices;
    Hashtbl.add processMap "insert" self#process_insert;
    Hashtbl.add processMap "add" self#process_add;
    Hashtbl.add processMap "remove" self#process_remove;
    Hashtbl.add processMap "remove_counter" self#process_remove_counter;
    Hashtbl.add processMap "batch_mutate" self#process_batch_mutate;
    Hashtbl.add processMap "truncate" self#process_truncate;
    Hashtbl.add processMap "describe_schema_versions" self#process_describe_schema_versions;
    Hashtbl.add processMap "describe_keyspaces" self#process_describe_keyspaces;
    Hashtbl.add processMap "describe_cluster_name" self#process_describe_cluster_name;
    Hashtbl.add processMap "describe_version" self#process_describe_version;
    Hashtbl.add processMap "describe_ring" self#process_describe_ring;
    Hashtbl.add processMap "describe_token_map" self#process_describe_token_map;
    Hashtbl.add processMap "describe_partitioner" self#process_describe_partitioner;
    Hashtbl.add processMap "describe_snitch" self#process_describe_snitch;
    Hashtbl.add processMap "describe_keyspace" self#process_describe_keyspace;
    Hashtbl.add processMap "describe_splits" self#process_describe_splits;
    Hashtbl.add processMap "system_add_column_family" self#process_system_add_column_family;
    Hashtbl.add processMap "system_drop_column_family" self#process_system_drop_column_family;
    Hashtbl.add processMap "system_add_keyspace" self#process_system_add_keyspace;
    Hashtbl.add processMap "system_drop_keyspace" self#process_system_drop_keyspace;
    Hashtbl.add processMap "system_update_keyspace" self#process_system_update_keyspace;
    Hashtbl.add processMap "system_update_column_family" self#process_system_update_column_family;
    Hashtbl.add processMap "execute_cql_query" self#process_execute_cql_query;
    Hashtbl.add processMap "prepare_cql_query" self#process_prepare_cql_query;
    Hashtbl.add processMap "execute_prepared_cql_query" self#process_execute_prepared_cql_query;
    Hashtbl.add processMap "set_cql_version" self#process_set_cql_version;
end

