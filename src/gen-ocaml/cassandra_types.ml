(*
 Autogenerated by Thrift Compiler (0.9.0)

 DO NOT EDIT UNLESS YOU ARE SURE YOU KNOW WHAT YOU ARE DOING
*)

open Thrift
module ConsistencyLevel = 
struct
  type t = 
    | ONE
    | QUORUM
    | LOCAL_QUORUM
    | EACH_QUORUM
    | ALL
    | ANY
    | TWO
    | THREE
  let to_i = function
    | ONE -> 1l
    | QUORUM -> 2l
    | LOCAL_QUORUM -> 3l
    | EACH_QUORUM -> 4l
    | ALL -> 5l
    | ANY -> 6l
    | TWO -> 7l
    | THREE -> 8l
  let of_i = function
    | 1l -> ONE
    | 2l -> QUORUM
    | 3l -> LOCAL_QUORUM
    | 4l -> EACH_QUORUM
    | 5l -> ALL
    | 6l -> ANY
    | 7l -> TWO
    | 8l -> THREE
    | _ -> raise Thrift_error
end
module IndexOperator = 
struct
  type t = 
    | EQ
    | GTE
    | GT
    | LTE
    | LT
  let to_i = function
    | EQ -> 0l
    | GTE -> 1l
    | GT -> 2l
    | LTE -> 3l
    | LT -> 4l
  let of_i = function
    | 0l -> EQ
    | 1l -> GTE
    | 2l -> GT
    | 3l -> LTE
    | 4l -> LT
    | _ -> raise Thrift_error
end
module IndexType = 
struct
  type t = 
    | KEYS
    | CUSTOM
  let to_i = function
    | KEYS -> 0l
    | CUSTOM -> 1l
  let of_i = function
    | 0l -> KEYS
    | 1l -> CUSTOM
    | _ -> raise Thrift_error
end
module Compression = 
struct
  type t = 
    | GZIP
    | NONE
  let to_i = function
    | GZIP -> 1l
    | NONE -> 2l
  let of_i = function
    | 1l -> GZIP
    | 2l -> NONE
    | _ -> raise Thrift_error
end
module CqlResultType = 
struct
  type t = 
    | ROWS
    | VOID
    | INT
  let to_i = function
    | ROWS -> 1l
    | VOID -> 2l
    | INT -> 3l
  let of_i = function
    | 1l -> ROWS
    | 2l -> VOID
    | 3l -> INT
    | _ -> raise Thrift_error
end
class column =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "column.name") | Some _x0 -> _x0
  method set_name _x0 = _name <- Some _x0
  method unset_name = _name <- None
  method reset_name = _name <- None

  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "column.value") | Some _x1 -> _x1
  method set_value _x1 = _value <- Some _x1
  method unset_value = _value <- None
  method reset_value = _value <- None

  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "column.timestamp") | Some _x2 -> _x2
  method set_timestamp _x2 = _timestamp <- Some _x2
  method unset_timestamp = _timestamp <- None
  method reset_timestamp = _timestamp <- None

  val mutable _ttl : Int32.t option = None
  method get_ttl = _ttl
  method grab_ttl = match _ttl with None->raise (Field_empty "column.ttl") | Some _x3 -> _x3
  method set_ttl _x3 = _ttl <- Some _x3
  method unset_ttl = _ttl <- None
  method reset_ttl = _ttl <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Column";
    (match _name with 
    | None -> raise (Field_empty "column._name")
    | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _value with None -> () | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,3);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _ttl with None -> () | Some _v -> 
      oprot#writeFieldBegin("ttl",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_column (iprot : Protocol.t) =
  let _str6 = new column in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t7,_id8) = iprot#readFieldBegin in
        if _t7 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id8 with 
          | 1 -> (if _t7 = Protocol.T_STRING then
              _str6#set_name iprot#readString
            else
              iprot#skip _t7)
          | 2 -> (if _t7 = Protocol.T_STRING then
              _str6#set_value iprot#readString
            else
              iprot#skip _t7)
          | 3 -> (if _t7 = Protocol.T_I64 then
              _str6#set_timestamp iprot#readI64
            else
              iprot#skip _t7)
          | 4 -> (if _t7 = Protocol.T_I32 then
              _str6#set_ttl iprot#readI32
            else
              iprot#skip _t7)
          | _ -> iprot#skip _t7);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str6

class superColumn =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "superColumn.name") | Some _x10 -> _x10
  method set_name _x10 = _name <- Some _x10
  method unset_name = _name <- None
  method reset_name = _name <- None

  val mutable _columns : column list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "superColumn.columns") | Some _x11 -> _x11
  method set_columns _x11 = _columns <- Some _x11
  method unset_columns = _columns <- None
  method reset_columns = _columns <- None

  method copy =
      let _new = Oo.copy self in
      if _columns <> None then
        _new#set_columns (List.map (fun x -> x#copy) self#grab_columns);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SuperColumn";
    (match _name with 
    | None -> raise (Field_empty "superColumn._name")
    | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with 
    | None -> raise (Field_empty "superColumn._columns")
    | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter14 ->         _iter14#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_superColumn (iprot : Protocol.t) =
  let _str15 = new superColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t16,_id17) = iprot#readFieldBegin in
        if _t16 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id17 with 
          | 1 -> (if _t16 = Protocol.T_STRING then
              _str15#set_name iprot#readString
            else
              iprot#skip _t16)
          | 2 -> (if _t16 = Protocol.T_LIST then
              _str15#set_columns 
                (let (_etype21,_size18) = iprot#readListBegin in
                  let _con22 = (Array.to_list (Array.init _size18 (fun _ -> (read_column iprot)))) in
                    iprot#readListEnd; _con22)
            else
              iprot#skip _t16)
          | _ -> iprot#skip _t16);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str15

class counterColumn =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "counterColumn.name") | Some _x24 -> _x24
  method set_name _x24 = _name <- Some _x24
  method unset_name = _name <- None
  method reset_name = _name <- None

  val mutable _value : Int64.t option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "counterColumn.value") | Some _x25 -> _x25
  method set_value _x25 = _value <- Some _x25
  method unset_value = _value <- None
  method reset_value = _value <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "CounterColumn";
    (match _name with 
    | None -> raise (Field_empty "counterColumn._name")
    | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _value with 
    | None -> raise (Field_empty "counterColumn._value")
    | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_I64,2);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_counterColumn (iprot : Protocol.t) =
  let _str28 = new counterColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t29,_id30) = iprot#readFieldBegin in
        if _t29 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id30 with 
          | 1 -> (if _t29 = Protocol.T_STRING then
              _str28#set_name iprot#readString
            else
              iprot#skip _t29)
          | 2 -> (if _t29 = Protocol.T_I64 then
              _str28#set_value iprot#readI64
            else
              iprot#skip _t29)
          | _ -> iprot#skip _t29);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str28

class counterSuperColumn =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "counterSuperColumn.name") | Some _x32 -> _x32
  method set_name _x32 = _name <- Some _x32
  method unset_name = _name <- None
  method reset_name = _name <- None

  val mutable _columns : counterColumn list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "counterSuperColumn.columns") | Some _x33 -> _x33
  method set_columns _x33 = _columns <- Some _x33
  method unset_columns = _columns <- None
  method reset_columns = _columns <- None

  method copy =
      let _new = Oo.copy self in
      if _columns <> None then
        _new#set_columns (List.map (fun x -> x#copy) self#grab_columns);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "CounterSuperColumn";
    (match _name with 
    | None -> raise (Field_empty "counterSuperColumn._name")
    | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with 
    | None -> raise (Field_empty "counterSuperColumn._columns")
    | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter36 ->         _iter36#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_counterSuperColumn (iprot : Protocol.t) =
  let _str37 = new counterSuperColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t38,_id39) = iprot#readFieldBegin in
        if _t38 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id39 with 
          | 1 -> (if _t38 = Protocol.T_STRING then
              _str37#set_name iprot#readString
            else
              iprot#skip _t38)
          | 2 -> (if _t38 = Protocol.T_LIST then
              _str37#set_columns 
                (let (_etype43,_size40) = iprot#readListBegin in
                  let _con44 = (Array.to_list (Array.init _size40 (fun _ -> (read_counterColumn iprot)))) in
                    iprot#readListEnd; _con44)
            else
              iprot#skip _t38)
          | _ -> iprot#skip _t38);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str37

class columnOrSuperColumn =
object (self)
  val mutable _column : column option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "columnOrSuperColumn.column") | Some _x46 -> _x46
  method set_column _x46 = _column <- Some _x46
  method unset_column = _column <- None
  method reset_column = _column <- None

  val mutable _super_column : superColumn option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnOrSuperColumn.super_column") | Some _x47 -> _x47
  method set_super_column _x47 = _super_column <- Some _x47
  method unset_super_column = _super_column <- None
  method reset_super_column = _super_column <- None

  val mutable _counter_column : counterColumn option = None
  method get_counter_column = _counter_column
  method grab_counter_column = match _counter_column with None->raise (Field_empty "columnOrSuperColumn.counter_column") | Some _x48 -> _x48
  method set_counter_column _x48 = _counter_column <- Some _x48
  method unset_counter_column = _counter_column <- None
  method reset_counter_column = _counter_column <- None

  val mutable _counter_super_column : counterSuperColumn option = None
  method get_counter_super_column = _counter_super_column
  method grab_counter_super_column = match _counter_super_column with None->raise (Field_empty "columnOrSuperColumn.counter_super_column") | Some _x49 -> _x49
  method set_counter_super_column _x49 = _counter_super_column <- Some _x49
  method unset_counter_super_column = _counter_super_column <- None
  method reset_counter_super_column = _counter_super_column <- None

  method copy =
      let _new = Oo.copy self in
      if _column <> None then
        _new#set_column self#grab_column#copy;
      if _super_column <> None then
        _new#set_super_column self#grab_super_column#copy;
      if _counter_column <> None then
        _new#set_counter_column self#grab_counter_column#copy;
      if _counter_super_column <> None then
        _new#set_counter_super_column self#grab_counter_super_column#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnOrSuperColumn";
    (match _column with None -> () | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _counter_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("counter_column",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _counter_super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("counter_super_column",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnOrSuperColumn (iprot : Protocol.t) =
  let _str52 = new columnOrSuperColumn in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t53,_id54) = iprot#readFieldBegin in
        if _t53 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id54 with 
          | 1 -> (if _t53 = Protocol.T_STRUCT then
              _str52#set_column (read_column iprot)
            else
              iprot#skip _t53)
          | 2 -> (if _t53 = Protocol.T_STRUCT then
              _str52#set_super_column (read_superColumn iprot)
            else
              iprot#skip _t53)
          | 3 -> (if _t53 = Protocol.T_STRUCT then
              _str52#set_counter_column (read_counterColumn iprot)
            else
              iprot#skip _t53)
          | 4 -> (if _t53 = Protocol.T_STRUCT then
              _str52#set_counter_super_column (read_counterSuperColumn iprot)
            else
              iprot#skip _t53)
          | _ -> iprot#skip _t53);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str52

class columnParent =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "columnParent.column_family") | Some _x56 -> _x56
  method set_column_family _x56 = _column_family <- Some _x56
  method unset_column_family = _column_family <- None
  method reset_column_family = _column_family <- None

  val mutable _super_column : string option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnParent.super_column") | Some _x57 -> _x57
  method set_super_column _x57 = _super_column <- Some _x57
  method unset_super_column = _super_column <- None
  method reset_super_column = _super_column <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnParent";
    (match _column_family with 
    | None -> raise (Field_empty "columnParent._column_family")
    | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnParent (iprot : Protocol.t) =
  let _str60 = new columnParent in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t61,_id62) = iprot#readFieldBegin in
        if _t61 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id62 with 
          | 3 -> (if _t61 = Protocol.T_STRING then
              _str60#set_column_family iprot#readString
            else
              iprot#skip _t61)
          | 4 -> (if _t61 = Protocol.T_STRING then
              _str60#set_super_column iprot#readString
            else
              iprot#skip _t61)
          | _ -> iprot#skip _t61);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str60

class columnPath =
object (self)
  val mutable _column_family : string option = None
  method get_column_family = _column_family
  method grab_column_family = match _column_family with None->raise (Field_empty "columnPath.column_family") | Some _x64 -> _x64
  method set_column_family _x64 = _column_family <- Some _x64
  method unset_column_family = _column_family <- None
  method reset_column_family = _column_family <- None

  val mutable _super_column : string option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "columnPath.super_column") | Some _x65 -> _x65
  method set_super_column _x65 = _super_column <- Some _x65
  method unset_super_column = _super_column <- None
  method reset_super_column = _super_column <- None

  val mutable _column : string option = None
  method get_column = _column
  method grab_column = match _column with None->raise (Field_empty "columnPath.column") | Some _x66 -> _x66
  method set_column _x66 = _column <- Some _x66
  method unset_column = _column <- None
  method reset_column = _column <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnPath";
    (match _column_family with 
    | None -> raise (Field_empty "columnPath._column_family")
    | Some _v -> 
      oprot#writeFieldBegin("column_family",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column with None -> () | Some _v -> 
      oprot#writeFieldBegin("column",Protocol.T_STRING,5);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnPath (iprot : Protocol.t) =
  let _str69 = new columnPath in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t70,_id71) = iprot#readFieldBegin in
        if _t70 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id71 with 
          | 3 -> (if _t70 = Protocol.T_STRING then
              _str69#set_column_family iprot#readString
            else
              iprot#skip _t70)
          | 4 -> (if _t70 = Protocol.T_STRING then
              _str69#set_super_column iprot#readString
            else
              iprot#skip _t70)
          | 5 -> (if _t70 = Protocol.T_STRING then
              _str69#set_column iprot#readString
            else
              iprot#skip _t70)
          | _ -> iprot#skip _t70);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str69

class sliceRange =
object (self)
  val mutable _start : string option = None
  method get_start = _start
  method grab_start = match _start with None->raise (Field_empty "sliceRange.start") | Some _x73 -> _x73
  method set_start _x73 = _start <- Some _x73
  method unset_start = _start <- None
  method reset_start = _start <- None

  val mutable _finish : string option = None
  method get_finish = _finish
  method grab_finish = match _finish with None->raise (Field_empty "sliceRange.finish") | Some _x74 -> _x74
  method set_finish _x74 = _finish <- Some _x74
  method unset_finish = _finish <- None
  method reset_finish = _finish <- None

  val mutable _reversed : bool = false
  method get_reversed = Some _reversed
  method grab_reversed = _reversed
  method set_reversed _x75 = _reversed <- _x75
  method reset_reversed = _reversed <- false

  val mutable _count : Int32.t = 100l
  method get_count = Some _count
  method grab_count = _count
  method set_count _x76 = _count <- _x76
  method reset_count = _count <- 100l

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SliceRange";
    (match _start with 
    | None -> raise (Field_empty "sliceRange._start")
    | Some _v -> 
      oprot#writeFieldBegin("start",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _finish with 
    | None -> raise (Field_empty "sliceRange._finish")
    | Some _v -> 
      oprot#writeFieldBegin("finish",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("reversed",Protocol.T_BOOL,3);
      oprot#writeBool(_reversed);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("count",Protocol.T_I32,4);
      oprot#writeI32(_count);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_sliceRange (iprot : Protocol.t) =
  let _str79 = new sliceRange in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t80,_id81) = iprot#readFieldBegin in
        if _t80 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id81 with 
          | 1 -> (if _t80 = Protocol.T_STRING then
              _str79#set_start iprot#readString
            else
              iprot#skip _t80)
          | 2 -> (if _t80 = Protocol.T_STRING then
              _str79#set_finish iprot#readString
            else
              iprot#skip _t80)
          | 3 -> (if _t80 = Protocol.T_BOOL then
              _str79#set_reversed iprot#readBool
            else
              iprot#skip _t80)
          | 4 -> (if _t80 = Protocol.T_I32 then
              _str79#set_count iprot#readI32
            else
              iprot#skip _t80)
          | _ -> iprot#skip _t80);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str79

class slicePredicate =
object (self)
  val mutable _column_names : string list option = None
  method get_column_names = _column_names
  method grab_column_names = match _column_names with None->raise (Field_empty "slicePredicate.column_names") | Some _x83 -> _x83
  method set_column_names _x83 = _column_names <- Some _x83
  method unset_column_names = _column_names <- None
  method reset_column_names = _column_names <- None

  val mutable _slice_range : sliceRange option = None
  method get_slice_range = _slice_range
  method grab_slice_range = match _slice_range with None->raise (Field_empty "slicePredicate.slice_range") | Some _x84 -> _x84
  method set_slice_range _x84 = _slice_range <- Some _x84
  method unset_slice_range = _slice_range <- None
  method reset_slice_range = _slice_range <- None

  method copy =
      let _new = Oo.copy self in
      if _slice_range <> None then
        _new#set_slice_range self#grab_slice_range#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SlicePredicate";
    (match _column_names with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_names",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter87 ->         oprot#writeString(_iter87);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _slice_range with None -> () | Some _v -> 
      oprot#writeFieldBegin("slice_range",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_slicePredicate (iprot : Protocol.t) =
  let _str88 = new slicePredicate in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t89,_id90) = iprot#readFieldBegin in
        if _t89 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id90 with 
          | 1 -> (if _t89 = Protocol.T_LIST then
              _str88#set_column_names 
                (let (_etype94,_size91) = iprot#readListBegin in
                  let _con95 = (Array.to_list (Array.init _size91 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con95)
            else
              iprot#skip _t89)
          | 2 -> (if _t89 = Protocol.T_STRUCT then
              _str88#set_slice_range (read_sliceRange iprot)
            else
              iprot#skip _t89)
          | _ -> iprot#skip _t89);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str88

class indexExpression =
object (self)
  val mutable _column_name : string option = None
  method get_column_name = _column_name
  method grab_column_name = match _column_name with None->raise (Field_empty "indexExpression.column_name") | Some _x97 -> _x97
  method set_column_name _x97 = _column_name <- Some _x97
  method unset_column_name = _column_name <- None
  method reset_column_name = _column_name <- None

  val mutable _op : IndexOperator.t option = None
  method get_op = _op
  method grab_op = match _op with None->raise (Field_empty "indexExpression.op") | Some _x98 -> _x98
  method set_op _x98 = _op <- Some _x98
  method unset_op = _op <- None
  method reset_op = _op <- None

  val mutable _value : string option = None
  method get_value = _value
  method grab_value = match _value with None->raise (Field_empty "indexExpression.value") | Some _x99 -> _x99
  method set_value _x99 = _value <- Some _x99
  method unset_value = _value <- None
  method reset_value = _value <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "IndexExpression";
    (match _column_name with 
    | None -> raise (Field_empty "indexExpression._column_name")
    | Some _v -> 
      oprot#writeFieldBegin("column_name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _op with 
    | None -> raise (Field_empty "indexExpression._op")
    | Some _v -> 
      oprot#writeFieldBegin("op",Protocol.T_I32,2);
      oprot#writeI32(IndexOperator.to_i _v);
      oprot#writeFieldEnd
    );
    (match _value with 
    | None -> raise (Field_empty "indexExpression._value")
    | Some _v -> 
      oprot#writeFieldBegin("value",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_indexExpression (iprot : Protocol.t) =
  let _str102 = new indexExpression in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t103,_id104) = iprot#readFieldBegin in
        if _t103 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id104 with 
          | 1 -> (if _t103 = Protocol.T_STRING then
              _str102#set_column_name iprot#readString
            else
              iprot#skip _t103)
          | 2 -> (if _t103 = Protocol.T_I32 then
              _str102#set_op (IndexOperator.of_i iprot#readI32)
            else
              iprot#skip _t103)
          | 3 -> (if _t103 = Protocol.T_STRING then
              _str102#set_value iprot#readString
            else
              iprot#skip _t103)
          | _ -> iprot#skip _t103);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str102

class indexClause =
object (self)
  val mutable _expressions : indexExpression list option = None
  method get_expressions = _expressions
  method grab_expressions = match _expressions with None->raise (Field_empty "indexClause.expressions") | Some _x106 -> _x106
  method set_expressions _x106 = _expressions <- Some _x106
  method unset_expressions = _expressions <- None
  method reset_expressions = _expressions <- None

  val mutable _start_key : string option = None
  method get_start_key = _start_key
  method grab_start_key = match _start_key with None->raise (Field_empty "indexClause.start_key") | Some _x107 -> _x107
  method set_start_key _x107 = _start_key <- Some _x107
  method unset_start_key = _start_key <- None
  method reset_start_key = _start_key <- None

  val mutable _count : Int32.t = 100l
  method get_count = Some _count
  method grab_count = _count
  method set_count _x108 = _count <- _x108
  method reset_count = _count <- 100l

  method copy =
      let _new = Oo.copy self in
      if _expressions <> None then
        _new#set_expressions (List.map (fun x -> x#copy) self#grab_expressions);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "IndexClause";
    (match _expressions with 
    | None -> raise (Field_empty "indexClause._expressions")
    | Some _v -> 
      oprot#writeFieldBegin("expressions",Protocol.T_LIST,1);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter111 ->         _iter111#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _start_key with 
    | None -> raise (Field_empty "indexClause._start_key")
    | Some _v -> 
      oprot#writeFieldBegin("start_key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("count",Protocol.T_I32,3);
      oprot#writeI32(_count);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_indexClause (iprot : Protocol.t) =
  let _str112 = new indexClause in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t113,_id114) = iprot#readFieldBegin in
        if _t113 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id114 with 
          | 1 -> (if _t113 = Protocol.T_LIST then
              _str112#set_expressions 
                (let (_etype118,_size115) = iprot#readListBegin in
                  let _con119 = (Array.to_list (Array.init _size115 (fun _ -> (read_indexExpression iprot)))) in
                    iprot#readListEnd; _con119)
            else
              iprot#skip _t113)
          | 2 -> (if _t113 = Protocol.T_STRING then
              _str112#set_start_key iprot#readString
            else
              iprot#skip _t113)
          | 3 -> (if _t113 = Protocol.T_I32 then
              _str112#set_count iprot#readI32
            else
              iprot#skip _t113)
          | _ -> iprot#skip _t113);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str112

class keyRange =
object (self)
  val mutable _start_key : string option = None
  method get_start_key = _start_key
  method grab_start_key = match _start_key with None->raise (Field_empty "keyRange.start_key") | Some _x121 -> _x121
  method set_start_key _x121 = _start_key <- Some _x121
  method unset_start_key = _start_key <- None
  method reset_start_key = _start_key <- None

  val mutable _end_key : string option = None
  method get_end_key = _end_key
  method grab_end_key = match _end_key with None->raise (Field_empty "keyRange.end_key") | Some _x122 -> _x122
  method set_end_key _x122 = _end_key <- Some _x122
  method unset_end_key = _end_key <- None
  method reset_end_key = _end_key <- None

  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "keyRange.start_token") | Some _x123 -> _x123
  method set_start_token _x123 = _start_token <- Some _x123
  method unset_start_token = _start_token <- None
  method reset_start_token = _start_token <- None

  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "keyRange.end_token") | Some _x124 -> _x124
  method set_end_token _x124 = _end_token <- Some _x124
  method unset_end_token = _end_token <- None
  method reset_end_token = _end_token <- None

  val mutable _row_filter : indexExpression list option = None
  method get_row_filter = _row_filter
  method grab_row_filter = match _row_filter with None->raise (Field_empty "keyRange.row_filter") | Some _x125 -> _x125
  method set_row_filter _x125 = _row_filter <- Some _x125
  method unset_row_filter = _row_filter <- None
  method reset_row_filter = _row_filter <- None

  val mutable _count : Int32.t = 100l
  method get_count = Some _count
  method grab_count = _count
  method set_count _x126 = _count <- _x126
  method reset_count = _count <- 100l

  method copy =
      let _new = Oo.copy self in
      if _row_filter <> None then
        _new#set_row_filter (List.map (fun x -> x#copy) self#grab_row_filter);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KeyRange";
    (match _start_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_key with None -> () | Some _v -> 
      oprot#writeFieldBegin("end_key",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _start_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with None -> () | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (
      oprot#writeFieldBegin("count",Protocol.T_I32,5);
      oprot#writeI32(_count);
      oprot#writeFieldEnd
    );
    (match _row_filter with None -> () | Some _v -> 
      oprot#writeFieldBegin("row_filter",Protocol.T_LIST,6);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter129 ->         _iter129#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_keyRange (iprot : Protocol.t) =
  let _str130 = new keyRange in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t131,_id132) = iprot#readFieldBegin in
        if _t131 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id132 with 
          | 1 -> (if _t131 = Protocol.T_STRING then
              _str130#set_start_key iprot#readString
            else
              iprot#skip _t131)
          | 2 -> (if _t131 = Protocol.T_STRING then
              _str130#set_end_key iprot#readString
            else
              iprot#skip _t131)
          | 3 -> (if _t131 = Protocol.T_STRING then
              _str130#set_start_token iprot#readString
            else
              iprot#skip _t131)
          | 4 -> (if _t131 = Protocol.T_STRING then
              _str130#set_end_token iprot#readString
            else
              iprot#skip _t131)
          | 6 -> (if _t131 = Protocol.T_LIST then
              _str130#set_row_filter 
                (let (_etype136,_size133) = iprot#readListBegin in
                  let _con137 = (Array.to_list (Array.init _size133 (fun _ -> (read_indexExpression iprot)))) in
                    iprot#readListEnd; _con137)
            else
              iprot#skip _t131)
          | 5 -> (if _t131 = Protocol.T_I32 then
              _str130#set_count iprot#readI32
            else
              iprot#skip _t131)
          | _ -> iprot#skip _t131);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str130

class keySlice =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "keySlice.key") | Some _x139 -> _x139
  method set_key _x139 = _key <- Some _x139
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _columns : columnOrSuperColumn list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "keySlice.columns") | Some _x140 -> _x140
  method set_columns _x140 = _columns <- Some _x140
  method unset_columns = _columns <- None
  method reset_columns = _columns <- None

  method copy =
      let _new = Oo.copy self in
      if _columns <> None then
        _new#set_columns (List.map (fun x -> x#copy) self#grab_columns);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KeySlice";
    (match _key with 
    | None -> raise (Field_empty "keySlice._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with 
    | None -> raise (Field_empty "keySlice._columns")
    | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter143 ->         _iter143#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_keySlice (iprot : Protocol.t) =
  let _str144 = new keySlice in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t145,_id146) = iprot#readFieldBegin in
        if _t145 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id146 with 
          | 1 -> (if _t145 = Protocol.T_STRING then
              _str144#set_key iprot#readString
            else
              iprot#skip _t145)
          | 2 -> (if _t145 = Protocol.T_LIST then
              _str144#set_columns 
                (let (_etype150,_size147) = iprot#readListBegin in
                  let _con151 = (Array.to_list (Array.init _size147 (fun _ -> (read_columnOrSuperColumn iprot)))) in
                    iprot#readListEnd; _con151)
            else
              iprot#skip _t145)
          | _ -> iprot#skip _t145);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str144

class keyCount =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "keyCount.key") | Some _x153 -> _x153
  method set_key _x153 = _key <- Some _x153
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _count : Int32.t option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "keyCount.count") | Some _x154 -> _x154
  method set_count _x154 = _count <- Some _x154
  method unset_count = _count <- None
  method reset_count = _count <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KeyCount";
    (match _key with 
    | None -> raise (Field_empty "keyCount._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _count with 
    | None -> raise (Field_empty "keyCount._count")
    | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_keyCount (iprot : Protocol.t) =
  let _str157 = new keyCount in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t158,_id159) = iprot#readFieldBegin in
        if _t158 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id159 with 
          | 1 -> (if _t158 = Protocol.T_STRING then
              _str157#set_key iprot#readString
            else
              iprot#skip _t158)
          | 2 -> (if _t158 = Protocol.T_I32 then
              _str157#set_count iprot#readI32
            else
              iprot#skip _t158)
          | _ -> iprot#skip _t158);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str157

class deletion =
object (self)
  val mutable _timestamp : Int64.t option = None
  method get_timestamp = _timestamp
  method grab_timestamp = match _timestamp with None->raise (Field_empty "deletion.timestamp") | Some _x161 -> _x161
  method set_timestamp _x161 = _timestamp <- Some _x161
  method unset_timestamp = _timestamp <- None
  method reset_timestamp = _timestamp <- None

  val mutable _super_column : string option = None
  method get_super_column = _super_column
  method grab_super_column = match _super_column with None->raise (Field_empty "deletion.super_column") | Some _x162 -> _x162
  method set_super_column _x162 = _super_column <- Some _x162
  method unset_super_column = _super_column <- None
  method reset_super_column = _super_column <- None

  val mutable _predicate : slicePredicate option = None
  method get_predicate = _predicate
  method grab_predicate = match _predicate with None->raise (Field_empty "deletion.predicate") | Some _x163 -> _x163
  method set_predicate _x163 = _predicate <- Some _x163
  method unset_predicate = _predicate <- None
  method reset_predicate = _predicate <- None

  method copy =
      let _new = Oo.copy self in
      if _predicate <> None then
        _new#set_predicate self#grab_predicate#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Deletion";
    (match _timestamp with None -> () | Some _v -> 
      oprot#writeFieldBegin("timestamp",Protocol.T_I64,1);
      oprot#writeI64(_v);
      oprot#writeFieldEnd
    );
    (match _super_column with None -> () | Some _v -> 
      oprot#writeFieldBegin("super_column",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _predicate with None -> () | Some _v -> 
      oprot#writeFieldBegin("predicate",Protocol.T_STRUCT,3);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_deletion (iprot : Protocol.t) =
  let _str166 = new deletion in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t167,_id168) = iprot#readFieldBegin in
        if _t167 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id168 with 
          | 1 -> (if _t167 = Protocol.T_I64 then
              _str166#set_timestamp iprot#readI64
            else
              iprot#skip _t167)
          | 2 -> (if _t167 = Protocol.T_STRING then
              _str166#set_super_column iprot#readString
            else
              iprot#skip _t167)
          | 3 -> (if _t167 = Protocol.T_STRUCT then
              _str166#set_predicate (read_slicePredicate iprot)
            else
              iprot#skip _t167)
          | _ -> iprot#skip _t167);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str166

class mutation =
object (self)
  val mutable _column_or_supercolumn : columnOrSuperColumn option = None
  method get_column_or_supercolumn = _column_or_supercolumn
  method grab_column_or_supercolumn = match _column_or_supercolumn with None->raise (Field_empty "mutation.column_or_supercolumn") | Some _x170 -> _x170
  method set_column_or_supercolumn _x170 = _column_or_supercolumn <- Some _x170
  method unset_column_or_supercolumn = _column_or_supercolumn <- None
  method reset_column_or_supercolumn = _column_or_supercolumn <- None

  val mutable _deletion : deletion option = None
  method get_deletion = _deletion
  method grab_deletion = match _deletion with None->raise (Field_empty "mutation.deletion") | Some _x171 -> _x171
  method set_deletion _x171 = _deletion <- Some _x171
  method unset_deletion = _deletion <- None
  method reset_deletion = _deletion <- None

  method copy =
      let _new = Oo.copy self in
      if _column_or_supercolumn <> None then
        _new#set_column_or_supercolumn self#grab_column_or_supercolumn#copy;
      if _deletion <> None then
        _new#set_deletion self#grab_deletion#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "Mutation";
    (match _column_or_supercolumn with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_or_supercolumn",Protocol.T_STRUCT,1);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    (match _deletion with None -> () | Some _v -> 
      oprot#writeFieldBegin("deletion",Protocol.T_STRUCT,2);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_mutation (iprot : Protocol.t) =
  let _str174 = new mutation in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t175,_id176) = iprot#readFieldBegin in
        if _t175 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id176 with 
          | 1 -> (if _t175 = Protocol.T_STRUCT then
              _str174#set_column_or_supercolumn (read_columnOrSuperColumn iprot)
            else
              iprot#skip _t175)
          | 2 -> (if _t175 = Protocol.T_STRUCT then
              _str174#set_deletion (read_deletion iprot)
            else
              iprot#skip _t175)
          | _ -> iprot#skip _t175);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str174

class endpointDetails =
object (self)
  val mutable _host : string option = None
  method get_host = _host
  method grab_host = match _host with None->raise (Field_empty "endpointDetails.host") | Some _x178 -> _x178
  method set_host _x178 = _host <- Some _x178
  method unset_host = _host <- None
  method reset_host = _host <- None

  val mutable _datacenter : string option = None
  method get_datacenter = _datacenter
  method grab_datacenter = match _datacenter with None->raise (Field_empty "endpointDetails.datacenter") | Some _x179 -> _x179
  method set_datacenter _x179 = _datacenter <- Some _x179
  method unset_datacenter = _datacenter <- None
  method reset_datacenter = _datacenter <- None

  val mutable _rack : string option = None
  method get_rack = _rack
  method grab_rack = match _rack with None->raise (Field_empty "endpointDetails.rack") | Some _x180 -> _x180
  method set_rack _x180 = _rack <- Some _x180
  method unset_rack = _rack <- None
  method reset_rack = _rack <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "EndpointDetails";
    (match _host with None -> () | Some _v -> 
      oprot#writeFieldBegin("host",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _datacenter with None -> () | Some _v -> 
      oprot#writeFieldBegin("datacenter",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _rack with None -> () | Some _v -> 
      oprot#writeFieldBegin("rack",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_endpointDetails (iprot : Protocol.t) =
  let _str183 = new endpointDetails in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t184,_id185) = iprot#readFieldBegin in
        if _t184 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id185 with 
          | 1 -> (if _t184 = Protocol.T_STRING then
              _str183#set_host iprot#readString
            else
              iprot#skip _t184)
          | 2 -> (if _t184 = Protocol.T_STRING then
              _str183#set_datacenter iprot#readString
            else
              iprot#skip _t184)
          | 3 -> (if _t184 = Protocol.T_STRING then
              _str183#set_rack iprot#readString
            else
              iprot#skip _t184)
          | _ -> iprot#skip _t184);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str183

class tokenRange =
object (self)
  val mutable _start_token : string option = None
  method get_start_token = _start_token
  method grab_start_token = match _start_token with None->raise (Field_empty "tokenRange.start_token") | Some _x187 -> _x187
  method set_start_token _x187 = _start_token <- Some _x187
  method unset_start_token = _start_token <- None
  method reset_start_token = _start_token <- None

  val mutable _end_token : string option = None
  method get_end_token = _end_token
  method grab_end_token = match _end_token with None->raise (Field_empty "tokenRange.end_token") | Some _x188 -> _x188
  method set_end_token _x188 = _end_token <- Some _x188
  method unset_end_token = _end_token <- None
  method reset_end_token = _end_token <- None

  val mutable _endpoints : string list option = None
  method get_endpoints = _endpoints
  method grab_endpoints = match _endpoints with None->raise (Field_empty "tokenRange.endpoints") | Some _x189 -> _x189
  method set_endpoints _x189 = _endpoints <- Some _x189
  method unset_endpoints = _endpoints <- None
  method reset_endpoints = _endpoints <- None

  val mutable _rpc_endpoints : string list option = None
  method get_rpc_endpoints = _rpc_endpoints
  method grab_rpc_endpoints = match _rpc_endpoints with None->raise (Field_empty "tokenRange.rpc_endpoints") | Some _x190 -> _x190
  method set_rpc_endpoints _x190 = _rpc_endpoints <- Some _x190
  method unset_rpc_endpoints = _rpc_endpoints <- None
  method reset_rpc_endpoints = _rpc_endpoints <- None

  val mutable _endpoint_details : endpointDetails list option = None
  method get_endpoint_details = _endpoint_details
  method grab_endpoint_details = match _endpoint_details with None->raise (Field_empty "tokenRange.endpoint_details") | Some _x191 -> _x191
  method set_endpoint_details _x191 = _endpoint_details <- Some _x191
  method unset_endpoint_details = _endpoint_details <- None
  method reset_endpoint_details = _endpoint_details <- None

  method copy =
      let _new = Oo.copy self in
      if _endpoint_details <> None then
        _new#set_endpoint_details (List.map (fun x -> x#copy) self#grab_endpoint_details);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TokenRange";
    (match _start_token with 
    | None -> raise (Field_empty "tokenRange._start_token")
    | Some _v -> 
      oprot#writeFieldBegin("start_token",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _end_token with 
    | None -> raise (Field_empty "tokenRange._end_token")
    | Some _v -> 
      oprot#writeFieldBegin("end_token",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _endpoints with 
    | None -> raise (Field_empty "tokenRange._endpoints")
    | Some _v -> 
      oprot#writeFieldBegin("endpoints",Protocol.T_LIST,3);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter194 ->         oprot#writeString(_iter194);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _rpc_endpoints with None -> () | Some _v -> 
      oprot#writeFieldBegin("rpc_endpoints",Protocol.T_LIST,4);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter195 ->         oprot#writeString(_iter195);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _endpoint_details with None -> () | Some _v -> 
      oprot#writeFieldBegin("endpoint_details",Protocol.T_LIST,5);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter196 ->         _iter196#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_tokenRange (iprot : Protocol.t) =
  let _str197 = new tokenRange in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t198,_id199) = iprot#readFieldBegin in
        if _t198 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id199 with 
          | 1 -> (if _t198 = Protocol.T_STRING then
              _str197#set_start_token iprot#readString
            else
              iprot#skip _t198)
          | 2 -> (if _t198 = Protocol.T_STRING then
              _str197#set_end_token iprot#readString
            else
              iprot#skip _t198)
          | 3 -> (if _t198 = Protocol.T_LIST then
              _str197#set_endpoints 
                (let (_etype203,_size200) = iprot#readListBegin in
                  let _con204 = (Array.to_list (Array.init _size200 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con204)
            else
              iprot#skip _t198)
          | 4 -> (if _t198 = Protocol.T_LIST then
              _str197#set_rpc_endpoints 
                (let (_etype208,_size205) = iprot#readListBegin in
                  let _con209 = (Array.to_list (Array.init _size205 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con209)
            else
              iprot#skip _t198)
          | 5 -> (if _t198 = Protocol.T_LIST then
              _str197#set_endpoint_details 
                (let (_etype213,_size210) = iprot#readListBegin in
                  let _con214 = (Array.to_list (Array.init _size210 (fun _ -> (read_endpointDetails iprot)))) in
                    iprot#readListEnd; _con214)
            else
              iprot#skip _t198)
          | _ -> iprot#skip _t198);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str197

class authenticationRequest =
object (self)
  val mutable _credentials : (string,string) Hashtbl.t option = None
  method get_credentials = _credentials
  method grab_credentials = match _credentials with None->raise (Field_empty "authenticationRequest.credentials") | Some _x216 -> _x216
  method set_credentials _x216 = _credentials <- Some _x216
  method unset_credentials = _credentials <- None
  method reset_credentials = _credentials <- None

  method copy =
      let _new = Oo.copy self in
      if _credentials <> None then
        _new#set_credentials (Hashtbl.copy self#grab_credentials);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "AuthenticationRequest";
    (match _credentials with 
    | None -> raise (Field_empty "authenticationRequest._credentials")
    | Some _v -> 
      oprot#writeFieldBegin("credentials",Protocol.T_MAP,1);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter219 -> fun _viter220 -> 
        oprot#writeString(_kiter219);
        oprot#writeString(_viter220);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_authenticationRequest (iprot : Protocol.t) =
  let _str221 = new authenticationRequest in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t222,_id223) = iprot#readFieldBegin in
        if _t222 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id223 with 
          | 1 -> (if _t222 = Protocol.T_MAP then
              _str221#set_credentials 
                (let (_ktype225,_vtype226,_size224) = iprot#readMapBegin in
                let _con228 = Hashtbl.create _size224 in
                  for i = 1 to _size224 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con228 _k _v
                  done; iprot#readMapEnd; _con228)
            else
              iprot#skip _t222)
          | _ -> iprot#skip _t222);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str221

class columnDef =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "columnDef.name") | Some _x230 -> _x230
  method set_name _x230 = _name <- Some _x230
  method unset_name = _name <- None
  method reset_name = _name <- None

  val mutable _validation_class : string option = None
  method get_validation_class = _validation_class
  method grab_validation_class = match _validation_class with None->raise (Field_empty "columnDef.validation_class") | Some _x231 -> _x231
  method set_validation_class _x231 = _validation_class <- Some _x231
  method unset_validation_class = _validation_class <- None
  method reset_validation_class = _validation_class <- None

  val mutable _index_type : IndexType.t option = None
  method get_index_type = _index_type
  method grab_index_type = match _index_type with None->raise (Field_empty "columnDef.index_type") | Some _x232 -> _x232
  method set_index_type _x232 = _index_type <- Some _x232
  method unset_index_type = _index_type <- None
  method reset_index_type = _index_type <- None

  val mutable _index_name : string option = None
  method get_index_name = _index_name
  method grab_index_name = match _index_name with None->raise (Field_empty "columnDef.index_name") | Some _x233 -> _x233
  method set_index_name _x233 = _index_name <- Some _x233
  method unset_index_name = _index_name <- None
  method reset_index_name = _index_name <- None

  val mutable _index_options : (string,string) Hashtbl.t option = None
  method get_index_options = _index_options
  method grab_index_options = match _index_options with None->raise (Field_empty "columnDef.index_options") | Some _x234 -> _x234
  method set_index_options _x234 = _index_options <- Some _x234
  method unset_index_options = _index_options <- None
  method reset_index_options = _index_options <- None

  method copy =
      let _new = Oo.copy self in
      if _index_options <> None then
        _new#set_index_options (Hashtbl.copy self#grab_index_options);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "ColumnDef";
    (match _name with 
    | None -> raise (Field_empty "columnDef._name")
    | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _validation_class with 
    | None -> raise (Field_empty "columnDef._validation_class")
    | Some _v -> 
      oprot#writeFieldBegin("validation_class",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _index_type with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_type",Protocol.T_I32,3);
      oprot#writeI32(IndexType.to_i _v);
      oprot#writeFieldEnd
    );
    (match _index_name with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_name",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _index_options with None -> () | Some _v -> 
      oprot#writeFieldBegin("index_options",Protocol.T_MAP,5);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter237 -> fun _viter238 -> 
        oprot#writeString(_kiter237);
        oprot#writeString(_viter238);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_columnDef (iprot : Protocol.t) =
  let _str239 = new columnDef in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t240,_id241) = iprot#readFieldBegin in
        if _t240 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id241 with 
          | 1 -> (if _t240 = Protocol.T_STRING then
              _str239#set_name iprot#readString
            else
              iprot#skip _t240)
          | 2 -> (if _t240 = Protocol.T_STRING then
              _str239#set_validation_class iprot#readString
            else
              iprot#skip _t240)
          | 3 -> (if _t240 = Protocol.T_I32 then
              _str239#set_index_type (IndexType.of_i iprot#readI32)
            else
              iprot#skip _t240)
          | 4 -> (if _t240 = Protocol.T_STRING then
              _str239#set_index_name iprot#readString
            else
              iprot#skip _t240)
          | 5 -> (if _t240 = Protocol.T_MAP then
              _str239#set_index_options 
                (let (_ktype243,_vtype244,_size242) = iprot#readMapBegin in
                let _con246 = Hashtbl.create _size242 in
                  for i = 1 to _size242 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con246 _k _v
                  done; iprot#readMapEnd; _con246)
            else
              iprot#skip _t240)
          | _ -> iprot#skip _t240);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str239

class cfDef =
object (self)
  val mutable _keyspace : string option = None
  method get_keyspace = _keyspace
  method grab_keyspace = match _keyspace with None->raise (Field_empty "cfDef.keyspace") | Some _x248 -> _x248
  method set_keyspace _x248 = _keyspace <- Some _x248
  method unset_keyspace = _keyspace <- None
  method reset_keyspace = _keyspace <- None

  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "cfDef.name") | Some _x249 -> _x249
  method set_name _x249 = _name <- Some _x249
  method unset_name = _name <- None
  method reset_name = _name <- None

  val mutable _column_type : string = "Standard"
  method get_column_type = Some _column_type
  method grab_column_type = _column_type
  method set_column_type _x250 = _column_type <- _x250
  method reset_column_type = _column_type <- "Standard"

  val mutable _comparator_type : string = "BytesType"
  method get_comparator_type = Some _comparator_type
  method grab_comparator_type = _comparator_type
  method set_comparator_type _x251 = _comparator_type <- _x251
  method reset_comparator_type = _comparator_type <- "BytesType"

  val mutable _subcomparator_type : string option = None
  method get_subcomparator_type = _subcomparator_type
  method grab_subcomparator_type = match _subcomparator_type with None->raise (Field_empty "cfDef.subcomparator_type") | Some _x252 -> _x252
  method set_subcomparator_type _x252 = _subcomparator_type <- Some _x252
  method unset_subcomparator_type = _subcomparator_type <- None
  method reset_subcomparator_type = _subcomparator_type <- None

  val mutable _comment : string option = None
  method get_comment = _comment
  method grab_comment = match _comment with None->raise (Field_empty "cfDef.comment") | Some _x253 -> _x253
  method set_comment _x253 = _comment <- Some _x253
  method unset_comment = _comment <- None
  method reset_comment = _comment <- None

  val mutable _read_repair_chance : float option = None
  method get_read_repair_chance = _read_repair_chance
  method grab_read_repair_chance = match _read_repair_chance with None->raise (Field_empty "cfDef.read_repair_chance") | Some _x254 -> _x254
  method set_read_repair_chance _x254 = _read_repair_chance <- Some _x254
  method unset_read_repair_chance = _read_repair_chance <- None
  method reset_read_repair_chance = _read_repair_chance <- None

  val mutable _column_metadata : columnDef list option = None
  method get_column_metadata = _column_metadata
  method grab_column_metadata = match _column_metadata with None->raise (Field_empty "cfDef.column_metadata") | Some _x255 -> _x255
  method set_column_metadata _x255 = _column_metadata <- Some _x255
  method unset_column_metadata = _column_metadata <- None
  method reset_column_metadata = _column_metadata <- None

  val mutable _gc_grace_seconds : Int32.t option = None
  method get_gc_grace_seconds = _gc_grace_seconds
  method grab_gc_grace_seconds = match _gc_grace_seconds with None->raise (Field_empty "cfDef.gc_grace_seconds") | Some _x256 -> _x256
  method set_gc_grace_seconds _x256 = _gc_grace_seconds <- Some _x256
  method unset_gc_grace_seconds = _gc_grace_seconds <- None
  method reset_gc_grace_seconds = _gc_grace_seconds <- None

  val mutable _default_validation_class : string option = None
  method get_default_validation_class = _default_validation_class
  method grab_default_validation_class = match _default_validation_class with None->raise (Field_empty "cfDef.default_validation_class") | Some _x257 -> _x257
  method set_default_validation_class _x257 = _default_validation_class <- Some _x257
  method unset_default_validation_class = _default_validation_class <- None
  method reset_default_validation_class = _default_validation_class <- None

  val mutable _id : Int32.t option = None
  method get_id = _id
  method grab_id = match _id with None->raise (Field_empty "cfDef.id") | Some _x258 -> _x258
  method set_id _x258 = _id <- Some _x258
  method unset_id = _id <- None
  method reset_id = _id <- None

  val mutable _min_compaction_threshold : Int32.t option = None
  method get_min_compaction_threshold = _min_compaction_threshold
  method grab_min_compaction_threshold = match _min_compaction_threshold with None->raise (Field_empty "cfDef.min_compaction_threshold") | Some _x259 -> _x259
  method set_min_compaction_threshold _x259 = _min_compaction_threshold <- Some _x259
  method unset_min_compaction_threshold = _min_compaction_threshold <- None
  method reset_min_compaction_threshold = _min_compaction_threshold <- None

  val mutable _max_compaction_threshold : Int32.t option = None
  method get_max_compaction_threshold = _max_compaction_threshold
  method grab_max_compaction_threshold = match _max_compaction_threshold with None->raise (Field_empty "cfDef.max_compaction_threshold") | Some _x260 -> _x260
  method set_max_compaction_threshold _x260 = _max_compaction_threshold <- Some _x260
  method unset_max_compaction_threshold = _max_compaction_threshold <- None
  method reset_max_compaction_threshold = _max_compaction_threshold <- None

  val mutable _replicate_on_write : bool option = None
  method get_replicate_on_write = _replicate_on_write
  method grab_replicate_on_write = match _replicate_on_write with None->raise (Field_empty "cfDef.replicate_on_write") | Some _x261 -> _x261
  method set_replicate_on_write _x261 = _replicate_on_write <- Some _x261
  method unset_replicate_on_write = _replicate_on_write <- None
  method reset_replicate_on_write = _replicate_on_write <- None

  val mutable _key_validation_class : string option = None
  method get_key_validation_class = _key_validation_class
  method grab_key_validation_class = match _key_validation_class with None->raise (Field_empty "cfDef.key_validation_class") | Some _x262 -> _x262
  method set_key_validation_class _x262 = _key_validation_class <- Some _x262
  method unset_key_validation_class = _key_validation_class <- None
  method reset_key_validation_class = _key_validation_class <- None

  val mutable _key_alias : string option = None
  method get_key_alias = _key_alias
  method grab_key_alias = match _key_alias with None->raise (Field_empty "cfDef.key_alias") | Some _x263 -> _x263
  method set_key_alias _x263 = _key_alias <- Some _x263
  method unset_key_alias = _key_alias <- None
  method reset_key_alias = _key_alias <- None

  val mutable _compaction_strategy : string option = None
  method get_compaction_strategy = _compaction_strategy
  method grab_compaction_strategy = match _compaction_strategy with None->raise (Field_empty "cfDef.compaction_strategy") | Some _x264 -> _x264
  method set_compaction_strategy _x264 = _compaction_strategy <- Some _x264
  method unset_compaction_strategy = _compaction_strategy <- None
  method reset_compaction_strategy = _compaction_strategy <- None

  val mutable _compaction_strategy_options : (string,string) Hashtbl.t option = None
  method get_compaction_strategy_options = _compaction_strategy_options
  method grab_compaction_strategy_options = match _compaction_strategy_options with None->raise (Field_empty "cfDef.compaction_strategy_options") | Some _x265 -> _x265
  method set_compaction_strategy_options _x265 = _compaction_strategy_options <- Some _x265
  method unset_compaction_strategy_options = _compaction_strategy_options <- None
  method reset_compaction_strategy_options = _compaction_strategy_options <- None

  val mutable _compression_options : (string,string) Hashtbl.t option = None
  method get_compression_options = _compression_options
  method grab_compression_options = match _compression_options with None->raise (Field_empty "cfDef.compression_options") | Some _x266 -> _x266
  method set_compression_options _x266 = _compression_options <- Some _x266
  method unset_compression_options = _compression_options <- None
  method reset_compression_options = _compression_options <- None

  val mutable _bloom_filter_fp_chance : float option = None
  method get_bloom_filter_fp_chance = _bloom_filter_fp_chance
  method grab_bloom_filter_fp_chance = match _bloom_filter_fp_chance with None->raise (Field_empty "cfDef.bloom_filter_fp_chance") | Some _x267 -> _x267
  method set_bloom_filter_fp_chance _x267 = _bloom_filter_fp_chance <- Some _x267
  method unset_bloom_filter_fp_chance = _bloom_filter_fp_chance <- None
  method reset_bloom_filter_fp_chance = _bloom_filter_fp_chance <- None

  val mutable _caching : string = "keys_only"
  method get_caching = Some _caching
  method grab_caching = _caching
  method set_caching _x268 = _caching <- _x268
  method reset_caching = _caching <- "keys_only"

  val mutable _dclocal_read_repair_chance : float = 0.00000
  method get_dclocal_read_repair_chance = Some _dclocal_read_repair_chance
  method grab_dclocal_read_repair_chance = _dclocal_read_repair_chance
  method set_dclocal_read_repair_chance _x269 = _dclocal_read_repair_chance <- _x269
  method reset_dclocal_read_repair_chance = _dclocal_read_repair_chance <- 0.00000

  val mutable _row_cache_size : float option = None
  method get_row_cache_size = _row_cache_size
  method grab_row_cache_size = match _row_cache_size with None->raise (Field_empty "cfDef.row_cache_size") | Some _x270 -> _x270
  method set_row_cache_size _x270 = _row_cache_size <- Some _x270
  method unset_row_cache_size = _row_cache_size <- None
  method reset_row_cache_size = _row_cache_size <- None

  val mutable _key_cache_size : float option = None
  method get_key_cache_size = _key_cache_size
  method grab_key_cache_size = match _key_cache_size with None->raise (Field_empty "cfDef.key_cache_size") | Some _x271 -> _x271
  method set_key_cache_size _x271 = _key_cache_size <- Some _x271
  method unset_key_cache_size = _key_cache_size <- None
  method reset_key_cache_size = _key_cache_size <- None

  val mutable _row_cache_save_period_in_seconds : Int32.t option = None
  method get_row_cache_save_period_in_seconds = _row_cache_save_period_in_seconds
  method grab_row_cache_save_period_in_seconds = match _row_cache_save_period_in_seconds with None->raise (Field_empty "cfDef.row_cache_save_period_in_seconds") | Some _x272 -> _x272
  method set_row_cache_save_period_in_seconds _x272 = _row_cache_save_period_in_seconds <- Some _x272
  method unset_row_cache_save_period_in_seconds = _row_cache_save_period_in_seconds <- None
  method reset_row_cache_save_period_in_seconds = _row_cache_save_period_in_seconds <- None

  val mutable _key_cache_save_period_in_seconds : Int32.t option = None
  method get_key_cache_save_period_in_seconds = _key_cache_save_period_in_seconds
  method grab_key_cache_save_period_in_seconds = match _key_cache_save_period_in_seconds with None->raise (Field_empty "cfDef.key_cache_save_period_in_seconds") | Some _x273 -> _x273
  method set_key_cache_save_period_in_seconds _x273 = _key_cache_save_period_in_seconds <- Some _x273
  method unset_key_cache_save_period_in_seconds = _key_cache_save_period_in_seconds <- None
  method reset_key_cache_save_period_in_seconds = _key_cache_save_period_in_seconds <- None

  val mutable _memtable_flush_after_mins : Int32.t option = None
  method get_memtable_flush_after_mins = _memtable_flush_after_mins
  method grab_memtable_flush_after_mins = match _memtable_flush_after_mins with None->raise (Field_empty "cfDef.memtable_flush_after_mins") | Some _x274 -> _x274
  method set_memtable_flush_after_mins _x274 = _memtable_flush_after_mins <- Some _x274
  method unset_memtable_flush_after_mins = _memtable_flush_after_mins <- None
  method reset_memtable_flush_after_mins = _memtable_flush_after_mins <- None

  val mutable _memtable_throughput_in_mb : Int32.t option = None
  method get_memtable_throughput_in_mb = _memtable_throughput_in_mb
  method grab_memtable_throughput_in_mb = match _memtable_throughput_in_mb with None->raise (Field_empty "cfDef.memtable_throughput_in_mb") | Some _x275 -> _x275
  method set_memtable_throughput_in_mb _x275 = _memtable_throughput_in_mb <- Some _x275
  method unset_memtable_throughput_in_mb = _memtable_throughput_in_mb <- None
  method reset_memtable_throughput_in_mb = _memtable_throughput_in_mb <- None

  val mutable _memtable_operations_in_millions : float option = None
  method get_memtable_operations_in_millions = _memtable_operations_in_millions
  method grab_memtable_operations_in_millions = match _memtable_operations_in_millions with None->raise (Field_empty "cfDef.memtable_operations_in_millions") | Some _x276 -> _x276
  method set_memtable_operations_in_millions _x276 = _memtable_operations_in_millions <- Some _x276
  method unset_memtable_operations_in_millions = _memtable_operations_in_millions <- None
  method reset_memtable_operations_in_millions = _memtable_operations_in_millions <- None

  val mutable _merge_shards_chance : float option = None
  method get_merge_shards_chance = _merge_shards_chance
  method grab_merge_shards_chance = match _merge_shards_chance with None->raise (Field_empty "cfDef.merge_shards_chance") | Some _x277 -> _x277
  method set_merge_shards_chance _x277 = _merge_shards_chance <- Some _x277
  method unset_merge_shards_chance = _merge_shards_chance <- None
  method reset_merge_shards_chance = _merge_shards_chance <- None

  val mutable _row_cache_provider : string option = None
  method get_row_cache_provider = _row_cache_provider
  method grab_row_cache_provider = match _row_cache_provider with None->raise (Field_empty "cfDef.row_cache_provider") | Some _x278 -> _x278
  method set_row_cache_provider _x278 = _row_cache_provider <- Some _x278
  method unset_row_cache_provider = _row_cache_provider <- None
  method reset_row_cache_provider = _row_cache_provider <- None

  val mutable _row_cache_keys_to_save : Int32.t option = None
  method get_row_cache_keys_to_save = _row_cache_keys_to_save
  method grab_row_cache_keys_to_save = match _row_cache_keys_to_save with None->raise (Field_empty "cfDef.row_cache_keys_to_save") | Some _x279 -> _x279
  method set_row_cache_keys_to_save _x279 = _row_cache_keys_to_save <- Some _x279
  method unset_row_cache_keys_to_save = _row_cache_keys_to_save <- None
  method reset_row_cache_keys_to_save = _row_cache_keys_to_save <- None

  method copy =
      let _new = Oo.copy self in
      if _column_metadata <> None then
        _new#set_column_metadata (List.map (fun x -> x#copy) self#grab_column_metadata);
      if _compaction_strategy_options <> None then
        _new#set_compaction_strategy_options (Hashtbl.copy self#grab_compaction_strategy_options);
      if _compression_options <> None then
        _new#set_compression_options (Hashtbl.copy self#grab_compression_options);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "CfDef";
    (match _keyspace with 
    | None -> raise (Field_empty "cfDef._keyspace")
    | Some _v -> 
      oprot#writeFieldBegin("keyspace",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _name with 
    | None -> raise (Field_empty "cfDef._name")
    | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _column_type with "Standard" -> () | _v -> 
      oprot#writeFieldBegin("column_type",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _comparator_type with "BytesType" -> () | _v -> 
      oprot#writeFieldBegin("comparator_type",Protocol.T_STRING,5);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _subcomparator_type with None -> () | Some _v -> 
      oprot#writeFieldBegin("subcomparator_type",Protocol.T_STRING,6);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _comment with None -> () | Some _v -> 
      oprot#writeFieldBegin("comment",Protocol.T_STRING,8);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _row_cache_size with None -> () | Some _v -> 
      oprot#writeFieldBegin("row_cache_size",Protocol.T_DOUBLE,9);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _key_cache_size with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_cache_size",Protocol.T_DOUBLE,11);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _read_repair_chance with None -> () | Some _v -> 
      oprot#writeFieldBegin("read_repair_chance",Protocol.T_DOUBLE,12);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _column_metadata with None -> () | Some _v -> 
      oprot#writeFieldBegin("column_metadata",Protocol.T_LIST,13);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter282 ->         _iter282#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _gc_grace_seconds with None -> () | Some _v -> 
      oprot#writeFieldBegin("gc_grace_seconds",Protocol.T_I32,14);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _default_validation_class with None -> () | Some _v -> 
      oprot#writeFieldBegin("default_validation_class",Protocol.T_STRING,15);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _id with None -> () | Some _v -> 
      oprot#writeFieldBegin("id",Protocol.T_I32,16);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _min_compaction_threshold with None -> () | Some _v -> 
      oprot#writeFieldBegin("min_compaction_threshold",Protocol.T_I32,17);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _max_compaction_threshold with None -> () | Some _v -> 
      oprot#writeFieldBegin("max_compaction_threshold",Protocol.T_I32,18);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _row_cache_save_period_in_seconds with None -> () | Some _v -> 
      oprot#writeFieldBegin("row_cache_save_period_in_seconds",Protocol.T_I32,19);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _key_cache_save_period_in_seconds with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_cache_save_period_in_seconds",Protocol.T_I32,20);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _memtable_flush_after_mins with None -> () | Some _v -> 
      oprot#writeFieldBegin("memtable_flush_after_mins",Protocol.T_I32,21);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _memtable_throughput_in_mb with None -> () | Some _v -> 
      oprot#writeFieldBegin("memtable_throughput_in_mb",Protocol.T_I32,22);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _memtable_operations_in_millions with None -> () | Some _v -> 
      oprot#writeFieldBegin("memtable_operations_in_millions",Protocol.T_DOUBLE,23);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _replicate_on_write with None -> () | Some _v -> 
      oprot#writeFieldBegin("replicate_on_write",Protocol.T_BOOL,24);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    (match _merge_shards_chance with None -> () | Some _v -> 
      oprot#writeFieldBegin("merge_shards_chance",Protocol.T_DOUBLE,25);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _key_validation_class with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_validation_class",Protocol.T_STRING,26);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _row_cache_provider with None -> () | Some _v -> 
      oprot#writeFieldBegin("row_cache_provider",Protocol.T_STRING,27);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _key_alias with None -> () | Some _v -> 
      oprot#writeFieldBegin("key_alias",Protocol.T_STRING,28);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _compaction_strategy with None -> () | Some _v -> 
      oprot#writeFieldBegin("compaction_strategy",Protocol.T_STRING,29);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _compaction_strategy_options with None -> () | Some _v -> 
      oprot#writeFieldBegin("compaction_strategy_options",Protocol.T_MAP,30);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter283 -> fun _viter284 -> 
        oprot#writeString(_kiter283);
        oprot#writeString(_viter284);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _row_cache_keys_to_save with None -> () | Some _v -> 
      oprot#writeFieldBegin("row_cache_keys_to_save",Protocol.T_I32,31);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _compression_options with None -> () | Some _v -> 
      oprot#writeFieldBegin("compression_options",Protocol.T_MAP,32);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter285 -> fun _viter286 -> 
        oprot#writeString(_kiter285);
        oprot#writeString(_viter286);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _bloom_filter_fp_chance with None -> () | Some _v -> 
      oprot#writeFieldBegin("bloom_filter_fp_chance",Protocol.T_DOUBLE,33);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    (match _caching with "keys_only" -> () | _v -> 
      oprot#writeFieldBegin("caching",Protocol.T_STRING,34);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _dclocal_read_repair_chance with 0.00000 -> () | _v -> 
      oprot#writeFieldBegin("dclocal_read_repair_chance",Protocol.T_DOUBLE,37);
      oprot#writeDouble(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_cfDef (iprot : Protocol.t) =
  let _str287 = new cfDef in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t288,_id289) = iprot#readFieldBegin in
        if _t288 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id289 with 
          | 1 -> (if _t288 = Protocol.T_STRING then
              _str287#set_keyspace iprot#readString
            else
              iprot#skip _t288)
          | 2 -> (if _t288 = Protocol.T_STRING then
              _str287#set_name iprot#readString
            else
              iprot#skip _t288)
          | 3 -> (if _t288 = Protocol.T_STRING then
              _str287#set_column_type iprot#readString
            else
              iprot#skip _t288)
          | 5 -> (if _t288 = Protocol.T_STRING then
              _str287#set_comparator_type iprot#readString
            else
              iprot#skip _t288)
          | 6 -> (if _t288 = Protocol.T_STRING then
              _str287#set_subcomparator_type iprot#readString
            else
              iprot#skip _t288)
          | 8 -> (if _t288 = Protocol.T_STRING then
              _str287#set_comment iprot#readString
            else
              iprot#skip _t288)
          | 12 -> (if _t288 = Protocol.T_DOUBLE then
              _str287#set_read_repair_chance iprot#readDouble
            else
              iprot#skip _t288)
          | 13 -> (if _t288 = Protocol.T_LIST then
              _str287#set_column_metadata 
                (let (_etype293,_size290) = iprot#readListBegin in
                  let _con294 = (Array.to_list (Array.init _size290 (fun _ -> (read_columnDef iprot)))) in
                    iprot#readListEnd; _con294)
            else
              iprot#skip _t288)
          | 14 -> (if _t288 = Protocol.T_I32 then
              _str287#set_gc_grace_seconds iprot#readI32
            else
              iprot#skip _t288)
          | 15 -> (if _t288 = Protocol.T_STRING then
              _str287#set_default_validation_class iprot#readString
            else
              iprot#skip _t288)
          | 16 -> (if _t288 = Protocol.T_I32 then
              _str287#set_id iprot#readI32
            else
              iprot#skip _t288)
          | 17 -> (if _t288 = Protocol.T_I32 then
              _str287#set_min_compaction_threshold iprot#readI32
            else
              iprot#skip _t288)
          | 18 -> (if _t288 = Protocol.T_I32 then
              _str287#set_max_compaction_threshold iprot#readI32
            else
              iprot#skip _t288)
          | 24 -> (if _t288 = Protocol.T_BOOL then
              _str287#set_replicate_on_write iprot#readBool
            else
              iprot#skip _t288)
          | 26 -> (if _t288 = Protocol.T_STRING then
              _str287#set_key_validation_class iprot#readString
            else
              iprot#skip _t288)
          | 28 -> (if _t288 = Protocol.T_STRING then
              _str287#set_key_alias iprot#readString
            else
              iprot#skip _t288)
          | 29 -> (if _t288 = Protocol.T_STRING then
              _str287#set_compaction_strategy iprot#readString
            else
              iprot#skip _t288)
          | 30 -> (if _t288 = Protocol.T_MAP then
              _str287#set_compaction_strategy_options 
                (let (_ktype296,_vtype297,_size295) = iprot#readMapBegin in
                let _con299 = Hashtbl.create _size295 in
                  for i = 1 to _size295 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con299 _k _v
                  done; iprot#readMapEnd; _con299)
            else
              iprot#skip _t288)
          | 32 -> (if _t288 = Protocol.T_MAP then
              _str287#set_compression_options 
                (let (_ktype301,_vtype302,_size300) = iprot#readMapBegin in
                let _con304 = Hashtbl.create _size300 in
                  for i = 1 to _size300 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con304 _k _v
                  done; iprot#readMapEnd; _con304)
            else
              iprot#skip _t288)
          | 33 -> (if _t288 = Protocol.T_DOUBLE then
              _str287#set_bloom_filter_fp_chance iprot#readDouble
            else
              iprot#skip _t288)
          | 34 -> (if _t288 = Protocol.T_STRING then
              _str287#set_caching iprot#readString
            else
              iprot#skip _t288)
          | 37 -> (if _t288 = Protocol.T_DOUBLE then
              _str287#set_dclocal_read_repair_chance iprot#readDouble
            else
              iprot#skip _t288)
          | 9 -> (if _t288 = Protocol.T_DOUBLE then
              _str287#set_row_cache_size iprot#readDouble
            else
              iprot#skip _t288)
          | 11 -> (if _t288 = Protocol.T_DOUBLE then
              _str287#set_key_cache_size iprot#readDouble
            else
              iprot#skip _t288)
          | 19 -> (if _t288 = Protocol.T_I32 then
              _str287#set_row_cache_save_period_in_seconds iprot#readI32
            else
              iprot#skip _t288)
          | 20 -> (if _t288 = Protocol.T_I32 then
              _str287#set_key_cache_save_period_in_seconds iprot#readI32
            else
              iprot#skip _t288)
          | 21 -> (if _t288 = Protocol.T_I32 then
              _str287#set_memtable_flush_after_mins iprot#readI32
            else
              iprot#skip _t288)
          | 22 -> (if _t288 = Protocol.T_I32 then
              _str287#set_memtable_throughput_in_mb iprot#readI32
            else
              iprot#skip _t288)
          | 23 -> (if _t288 = Protocol.T_DOUBLE then
              _str287#set_memtable_operations_in_millions iprot#readDouble
            else
              iprot#skip _t288)
          | 25 -> (if _t288 = Protocol.T_DOUBLE then
              _str287#set_merge_shards_chance iprot#readDouble
            else
              iprot#skip _t288)
          | 27 -> (if _t288 = Protocol.T_STRING then
              _str287#set_row_cache_provider iprot#readString
            else
              iprot#skip _t288)
          | 31 -> (if _t288 = Protocol.T_I32 then
              _str287#set_row_cache_keys_to_save iprot#readI32
            else
              iprot#skip _t288)
          | _ -> iprot#skip _t288);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str287

class ksDef =
object (self)
  val mutable _name : string option = None
  method get_name = _name
  method grab_name = match _name with None->raise (Field_empty "ksDef.name") | Some _x306 -> _x306
  method set_name _x306 = _name <- Some _x306
  method unset_name = _name <- None
  method reset_name = _name <- None

  val mutable _strategy_class : string option = None
  method get_strategy_class = _strategy_class
  method grab_strategy_class = match _strategy_class with None->raise (Field_empty "ksDef.strategy_class") | Some _x307 -> _x307
  method set_strategy_class _x307 = _strategy_class <- Some _x307
  method unset_strategy_class = _strategy_class <- None
  method reset_strategy_class = _strategy_class <- None

  val mutable _strategy_options : (string,string) Hashtbl.t option = None
  method get_strategy_options = _strategy_options
  method grab_strategy_options = match _strategy_options with None->raise (Field_empty "ksDef.strategy_options") | Some _x308 -> _x308
  method set_strategy_options _x308 = _strategy_options <- Some _x308
  method unset_strategy_options = _strategy_options <- None
  method reset_strategy_options = _strategy_options <- None

  val mutable _replication_factor : Int32.t option = None
  method get_replication_factor = _replication_factor
  method grab_replication_factor = match _replication_factor with None->raise (Field_empty "ksDef.replication_factor") | Some _x309 -> _x309
  method set_replication_factor _x309 = _replication_factor <- Some _x309
  method unset_replication_factor = _replication_factor <- None
  method reset_replication_factor = _replication_factor <- None

  val mutable _cf_defs : cfDef list option = None
  method get_cf_defs = _cf_defs
  method grab_cf_defs = match _cf_defs with None->raise (Field_empty "ksDef.cf_defs") | Some _x310 -> _x310
  method set_cf_defs _x310 = _cf_defs <- Some _x310
  method unset_cf_defs = _cf_defs <- None
  method reset_cf_defs = _cf_defs <- None

  val mutable _durable_writes : bool = true
  method get_durable_writes = Some _durable_writes
  method grab_durable_writes = _durable_writes
  method set_durable_writes _x311 = _durable_writes <- _x311
  method reset_durable_writes = _durable_writes <- true

  method copy =
      let _new = Oo.copy self in
      if _strategy_options <> None then
        _new#set_strategy_options (Hashtbl.copy self#grab_strategy_options);
      if _cf_defs <> None then
        _new#set_cf_defs (List.map (fun x -> x#copy) self#grab_cf_defs);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "KsDef";
    (match _name with 
    | None -> raise (Field_empty "ksDef._name")
    | Some _v -> 
      oprot#writeFieldBegin("name",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _strategy_class with 
    | None -> raise (Field_empty "ksDef._strategy_class")
    | Some _v -> 
      oprot#writeFieldBegin("strategy_class",Protocol.T_STRING,2);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _strategy_options with None -> () | Some _v -> 
      oprot#writeFieldBegin("strategy_options",Protocol.T_MAP,3);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter314 -> fun _viter315 -> 
        oprot#writeString(_kiter314);
        oprot#writeString(_viter315);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _replication_factor with None -> () | Some _v -> 
      oprot#writeFieldBegin("replication_factor",Protocol.T_I32,4);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _cf_defs with 
    | None -> raise (Field_empty "ksDef._cf_defs")
    | Some _v -> 
      oprot#writeFieldBegin("cf_defs",Protocol.T_LIST,5);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter316 ->         _iter316#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _durable_writes with true -> () | _v -> 
      oprot#writeFieldBegin("durable_writes",Protocol.T_BOOL,6);
      oprot#writeBool(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_ksDef (iprot : Protocol.t) =
  let _str317 = new ksDef in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t318,_id319) = iprot#readFieldBegin in
        if _t318 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id319 with 
          | 1 -> (if _t318 = Protocol.T_STRING then
              _str317#set_name iprot#readString
            else
              iprot#skip _t318)
          | 2 -> (if _t318 = Protocol.T_STRING then
              _str317#set_strategy_class iprot#readString
            else
              iprot#skip _t318)
          | 3 -> (if _t318 = Protocol.T_MAP then
              _str317#set_strategy_options 
                (let (_ktype321,_vtype322,_size320) = iprot#readMapBegin in
                let _con324 = Hashtbl.create _size320 in
                  for i = 1 to _size320 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con324 _k _v
                  done; iprot#readMapEnd; _con324)
            else
              iprot#skip _t318)
          | 4 -> (if _t318 = Protocol.T_I32 then
              _str317#set_replication_factor iprot#readI32
            else
              iprot#skip _t318)
          | 5 -> (if _t318 = Protocol.T_LIST then
              _str317#set_cf_defs 
                (let (_etype328,_size325) = iprot#readListBegin in
                  let _con329 = (Array.to_list (Array.init _size325 (fun _ -> (read_cfDef iprot)))) in
                    iprot#readListEnd; _con329)
            else
              iprot#skip _t318)
          | 6 -> (if _t318 = Protocol.T_BOOL then
              _str317#set_durable_writes iprot#readBool
            else
              iprot#skip _t318)
          | _ -> iprot#skip _t318);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str317

class cqlRow =
object (self)
  val mutable _key : string option = None
  method get_key = _key
  method grab_key = match _key with None->raise (Field_empty "cqlRow.key") | Some _x331 -> _x331
  method set_key _x331 = _key <- Some _x331
  method unset_key = _key <- None
  method reset_key = _key <- None

  val mutable _columns : column list option = None
  method get_columns = _columns
  method grab_columns = match _columns with None->raise (Field_empty "cqlRow.columns") | Some _x332 -> _x332
  method set_columns _x332 = _columns <- Some _x332
  method unset_columns = _columns <- None
  method reset_columns = _columns <- None

  method copy =
      let _new = Oo.copy self in
      if _columns <> None then
        _new#set_columns (List.map (fun x -> x#copy) self#grab_columns);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "CqlRow";
    (match _key with 
    | None -> raise (Field_empty "cqlRow._key")
    | Some _v -> 
      oprot#writeFieldBegin("key",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _columns with 
    | None -> raise (Field_empty "cqlRow._columns")
    | Some _v -> 
      oprot#writeFieldBegin("columns",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter335 ->         _iter335#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_cqlRow (iprot : Protocol.t) =
  let _str336 = new cqlRow in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t337,_id338) = iprot#readFieldBegin in
        if _t337 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id338 with 
          | 1 -> (if _t337 = Protocol.T_STRING then
              _str336#set_key iprot#readString
            else
              iprot#skip _t337)
          | 2 -> (if _t337 = Protocol.T_LIST then
              _str336#set_columns 
                (let (_etype342,_size339) = iprot#readListBegin in
                  let _con343 = (Array.to_list (Array.init _size339 (fun _ -> (read_column iprot)))) in
                    iprot#readListEnd; _con343)
            else
              iprot#skip _t337)
          | _ -> iprot#skip _t337);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str336

class cqlMetadata =
object (self)
  val mutable _name_types : (string,string) Hashtbl.t option = None
  method get_name_types = _name_types
  method grab_name_types = match _name_types with None->raise (Field_empty "cqlMetadata.name_types") | Some _x345 -> _x345
  method set_name_types _x345 = _name_types <- Some _x345
  method unset_name_types = _name_types <- None
  method reset_name_types = _name_types <- None

  val mutable _value_types : (string,string) Hashtbl.t option = None
  method get_value_types = _value_types
  method grab_value_types = match _value_types with None->raise (Field_empty "cqlMetadata.value_types") | Some _x346 -> _x346
  method set_value_types _x346 = _value_types <- Some _x346
  method unset_value_types = _value_types <- None
  method reset_value_types = _value_types <- None

  val mutable _default_name_type : string option = None
  method get_default_name_type = _default_name_type
  method grab_default_name_type = match _default_name_type with None->raise (Field_empty "cqlMetadata.default_name_type") | Some _x347 -> _x347
  method set_default_name_type _x347 = _default_name_type <- Some _x347
  method unset_default_name_type = _default_name_type <- None
  method reset_default_name_type = _default_name_type <- None

  val mutable _default_value_type : string option = None
  method get_default_value_type = _default_value_type
  method grab_default_value_type = match _default_value_type with None->raise (Field_empty "cqlMetadata.default_value_type") | Some _x348 -> _x348
  method set_default_value_type _x348 = _default_value_type <- Some _x348
  method unset_default_value_type = _default_value_type <- None
  method reset_default_value_type = _default_value_type <- None

  method copy =
      let _new = Oo.copy self in
      if _name_types <> None then
        _new#set_name_types (Hashtbl.copy self#grab_name_types);
      if _value_types <> None then
        _new#set_value_types (Hashtbl.copy self#grab_value_types);
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "CqlMetadata";
    (match _name_types with 
    | None -> raise (Field_empty "cqlMetadata._name_types")
    | Some _v -> 
      oprot#writeFieldBegin("name_types",Protocol.T_MAP,1);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter351 -> fun _viter352 -> 
        oprot#writeString(_kiter351);
        oprot#writeString(_viter352);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _value_types with 
    | None -> raise (Field_empty "cqlMetadata._value_types")
    | Some _v -> 
      oprot#writeFieldBegin("value_types",Protocol.T_MAP,2);
      oprot#writeMapBegin(Protocol.T_STRING,Protocol.T_STRING,Hashtbl.length _v);
      Hashtbl.iter (fun _kiter353 -> fun _viter354 -> 
        oprot#writeString(_kiter353);
        oprot#writeString(_viter354);
      ) _v;
      oprot#writeMapEnd;
      oprot#writeFieldEnd
    );
    (match _default_name_type with 
    | None -> raise (Field_empty "cqlMetadata._default_name_type")
    | Some _v -> 
      oprot#writeFieldBegin("default_name_type",Protocol.T_STRING,3);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    (match _default_value_type with 
    | None -> raise (Field_empty "cqlMetadata._default_value_type")
    | Some _v -> 
      oprot#writeFieldBegin("default_value_type",Protocol.T_STRING,4);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_cqlMetadata (iprot : Protocol.t) =
  let _str355 = new cqlMetadata in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t356,_id357) = iprot#readFieldBegin in
        if _t356 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id357 with 
          | 1 -> (if _t356 = Protocol.T_MAP then
              _str355#set_name_types 
                (let (_ktype359,_vtype360,_size358) = iprot#readMapBegin in
                let _con362 = Hashtbl.create _size358 in
                  for i = 1 to _size358 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con362 _k _v
                  done; iprot#readMapEnd; _con362)
            else
              iprot#skip _t356)
          | 2 -> (if _t356 = Protocol.T_MAP then
              _str355#set_value_types 
                (let (_ktype364,_vtype365,_size363) = iprot#readMapBegin in
                let _con367 = Hashtbl.create _size363 in
                  for i = 1 to _size363 do
                    let _k = iprot#readString in
                    let _v = iprot#readString in
                      Hashtbl.add _con367 _k _v
                  done; iprot#readMapEnd; _con367)
            else
              iprot#skip _t356)
          | 3 -> (if _t356 = Protocol.T_STRING then
              _str355#set_default_name_type iprot#readString
            else
              iprot#skip _t356)
          | 4 -> (if _t356 = Protocol.T_STRING then
              _str355#set_default_value_type iprot#readString
            else
              iprot#skip _t356)
          | _ -> iprot#skip _t356);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str355

class cqlResult =
object (self)
  val mutable _type : CqlResultType.t option = None
  method get_type = _type
  method grab_type = match _type with None->raise (Field_empty "cqlResult.type") | Some _x369 -> _x369
  method set_type _x369 = _type <- Some _x369
  method unset_type = _type <- None
  method reset_type = _type <- None

  val mutable _rows : cqlRow list option = None
  method get_rows = _rows
  method grab_rows = match _rows with None->raise (Field_empty "cqlResult.rows") | Some _x370 -> _x370
  method set_rows _x370 = _rows <- Some _x370
  method unset_rows = _rows <- None
  method reset_rows = _rows <- None

  val mutable _num : Int32.t option = None
  method get_num = _num
  method grab_num = match _num with None->raise (Field_empty "cqlResult.num") | Some _x371 -> _x371
  method set_num _x371 = _num <- Some _x371
  method unset_num = _num <- None
  method reset_num = _num <- None

  val mutable _schema : cqlMetadata option = None
  method get_schema = _schema
  method grab_schema = match _schema with None->raise (Field_empty "cqlResult.schema") | Some _x372 -> _x372
  method set_schema _x372 = _schema <- Some _x372
  method unset_schema = _schema <- None
  method reset_schema = _schema <- None

  method copy =
      let _new = Oo.copy self in
      if _rows <> None then
        _new#set_rows (List.map (fun x -> x#copy) self#grab_rows);
      if _schema <> None then
        _new#set_schema self#grab_schema#copy;
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "CqlResult";
    (match _type with 
    | None -> raise (Field_empty "cqlResult._type")
    | Some _v -> 
      oprot#writeFieldBegin("type",Protocol.T_I32,1);
      oprot#writeI32(CqlResultType.to_i _v);
      oprot#writeFieldEnd
    );
    (match _rows with None -> () | Some _v -> 
      oprot#writeFieldBegin("rows",Protocol.T_LIST,2);
      oprot#writeListBegin(Protocol.T_STRUCT,List.length _v);
      List.iter (fun _iter375 ->         _iter375#write(oprot);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _num with None -> () | Some _v -> 
      oprot#writeFieldBegin("num",Protocol.T_I32,3);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _schema with None -> () | Some _v -> 
      oprot#writeFieldBegin("schema",Protocol.T_STRUCT,4);
      _v#write(oprot);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_cqlResult (iprot : Protocol.t) =
  let _str376 = new cqlResult in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t377,_id378) = iprot#readFieldBegin in
        if _t377 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id378 with 
          | 1 -> (if _t377 = Protocol.T_I32 then
              _str376#set_type (CqlResultType.of_i iprot#readI32)
            else
              iprot#skip _t377)
          | 2 -> (if _t377 = Protocol.T_LIST then
              _str376#set_rows 
                (let (_etype382,_size379) = iprot#readListBegin in
                  let _con383 = (Array.to_list (Array.init _size379 (fun _ -> (read_cqlRow iprot)))) in
                    iprot#readListEnd; _con383)
            else
              iprot#skip _t377)
          | 3 -> (if _t377 = Protocol.T_I32 then
              _str376#set_num iprot#readI32
            else
              iprot#skip _t377)
          | 4 -> (if _t377 = Protocol.T_STRUCT then
              _str376#set_schema (read_cqlMetadata iprot)
            else
              iprot#skip _t377)
          | _ -> iprot#skip _t377);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str376

class cqlPreparedResult =
object (self)
  val mutable _itemId : Int32.t option = None
  method get_itemId = _itemId
  method grab_itemId = match _itemId with None->raise (Field_empty "cqlPreparedResult.itemId") | Some _x385 -> _x385
  method set_itemId _x385 = _itemId <- Some _x385
  method unset_itemId = _itemId <- None
  method reset_itemId = _itemId <- None

  val mutable _count : Int32.t option = None
  method get_count = _count
  method grab_count = match _count with None->raise (Field_empty "cqlPreparedResult.count") | Some _x386 -> _x386
  method set_count _x386 = _count <- Some _x386
  method unset_count = _count <- None
  method reset_count = _count <- None

  val mutable _variable_types : string list option = None
  method get_variable_types = _variable_types
  method grab_variable_types = match _variable_types with None->raise (Field_empty "cqlPreparedResult.variable_types") | Some _x387 -> _x387
  method set_variable_types _x387 = _variable_types <- Some _x387
  method unset_variable_types = _variable_types <- None
  method reset_variable_types = _variable_types <- None

  val mutable _variable_names : string list option = None
  method get_variable_names = _variable_names
  method grab_variable_names = match _variable_names with None->raise (Field_empty "cqlPreparedResult.variable_names") | Some _x388 -> _x388
  method set_variable_names _x388 = _variable_names <- Some _x388
  method unset_variable_names = _variable_names <- None
  method reset_variable_names = _variable_names <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "CqlPreparedResult";
    (match _itemId with 
    | None -> raise (Field_empty "cqlPreparedResult._itemId")
    | Some _v -> 
      oprot#writeFieldBegin("itemId",Protocol.T_I32,1);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _count with 
    | None -> raise (Field_empty "cqlPreparedResult._count")
    | Some _v -> 
      oprot#writeFieldBegin("count",Protocol.T_I32,2);
      oprot#writeI32(_v);
      oprot#writeFieldEnd
    );
    (match _variable_types with None -> () | Some _v -> 
      oprot#writeFieldBegin("variable_types",Protocol.T_LIST,3);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter391 ->         oprot#writeString(_iter391);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    (match _variable_names with None -> () | Some _v -> 
      oprot#writeFieldBegin("variable_names",Protocol.T_LIST,4);
      oprot#writeListBegin(Protocol.T_STRING,List.length _v);
      List.iter (fun _iter392 ->         oprot#writeString(_iter392);
      ) _v;
      oprot#writeListEnd;
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
let rec read_cqlPreparedResult (iprot : Protocol.t) =
  let _str393 = new cqlPreparedResult in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t394,_id395) = iprot#readFieldBegin in
        if _t394 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id395 with 
          | 1 -> (if _t394 = Protocol.T_I32 then
              _str393#set_itemId iprot#readI32
            else
              iprot#skip _t394)
          | 2 -> (if _t394 = Protocol.T_I32 then
              _str393#set_count iprot#readI32
            else
              iprot#skip _t394)
          | 3 -> (if _t394 = Protocol.T_LIST then
              _str393#set_variable_types 
                (let (_etype399,_size396) = iprot#readListBegin in
                  let _con400 = (Array.to_list (Array.init _size396 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con400)
            else
              iprot#skip _t394)
          | 4 -> (if _t394 = Protocol.T_LIST then
              _str393#set_variable_names 
                (let (_etype404,_size401) = iprot#readListBegin in
                  let _con405 = (Array.to_list (Array.init _size401 (fun _ -> iprot#readString))) in
                    iprot#readListEnd; _con405)
            else
              iprot#skip _t394)
          | _ -> iprot#skip _t394);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str393

class notFoundException =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "NotFoundException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception NotFoundException of notFoundException
let rec read_notFoundException (iprot : Protocol.t) =
  let _str409 = new notFoundException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t410,_id411) = iprot#readFieldBegin in
        if _t410 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id411 with 
          | _ -> iprot#skip _t410);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str409

class invalidRequestException =
object (self)
  val mutable _why : string option = None
  method get_why = _why
  method grab_why = match _why with None->raise (Field_empty "invalidRequestException.why") | Some _x413 -> _x413
  method set_why _x413 = _why <- Some _x413
  method unset_why = _why <- None
  method reset_why = _why <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "InvalidRequestException";
    (match _why with 
    | None -> raise (Field_empty "invalidRequestException._why")
    | Some _v -> 
      oprot#writeFieldBegin("why",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception InvalidRequestException of invalidRequestException
let rec read_invalidRequestException (iprot : Protocol.t) =
  let _str416 = new invalidRequestException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t417,_id418) = iprot#readFieldBegin in
        if _t417 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id418 with 
          | 1 -> (if _t417 = Protocol.T_STRING then
              _str416#set_why iprot#readString
            else
              iprot#skip _t417)
          | _ -> iprot#skip _t417);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str416

class unavailableException =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "UnavailableException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception UnavailableException of unavailableException
let rec read_unavailableException (iprot : Protocol.t) =
  let _str422 = new unavailableException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t423,_id424) = iprot#readFieldBegin in
        if _t423 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id424 with 
          | _ -> iprot#skip _t423);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str422

class timedOutException =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "TimedOutException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception TimedOutException of timedOutException
let rec read_timedOutException (iprot : Protocol.t) =
  let _str428 = new timedOutException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t429,_id430) = iprot#readFieldBegin in
        if _t429 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id430 with 
          | _ -> iprot#skip _t429);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str428

class authenticationException =
object (self)
  val mutable _why : string option = None
  method get_why = _why
  method grab_why = match _why with None->raise (Field_empty "authenticationException.why") | Some _x432 -> _x432
  method set_why _x432 = _why <- Some _x432
  method unset_why = _why <- None
  method reset_why = _why <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "AuthenticationException";
    (match _why with 
    | None -> raise (Field_empty "authenticationException._why")
    | Some _v -> 
      oprot#writeFieldBegin("why",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception AuthenticationException of authenticationException
let rec read_authenticationException (iprot : Protocol.t) =
  let _str435 = new authenticationException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t436,_id437) = iprot#readFieldBegin in
        if _t436 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id437 with 
          | 1 -> (if _t436 = Protocol.T_STRING then
              _str435#set_why iprot#readString
            else
              iprot#skip _t436)
          | _ -> iprot#skip _t436);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str435

class authorizationException =
object (self)
  val mutable _why : string option = None
  method get_why = _why
  method grab_why = match _why with None->raise (Field_empty "authorizationException.why") | Some _x439 -> _x439
  method set_why _x439 = _why <- Some _x439
  method unset_why = _why <- None
  method reset_why = _why <- None

  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "AuthorizationException";
    (match _why with 
    | None -> raise (Field_empty "authorizationException._why")
    | Some _v -> 
      oprot#writeFieldBegin("why",Protocol.T_STRING,1);
      oprot#writeString(_v);
      oprot#writeFieldEnd
    );
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception AuthorizationException of authorizationException
let rec read_authorizationException (iprot : Protocol.t) =
  let _str442 = new authorizationException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t443,_id444) = iprot#readFieldBegin in
        if _t443 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id444 with 
          | 1 -> (if _t443 = Protocol.T_STRING then
              _str442#set_why iprot#readString
            else
              iprot#skip _t443)
          | _ -> iprot#skip _t443);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str442

class schemaDisagreementException =
object (self)
  method copy =
      let _new = Oo.copy self in
    _new
  method write (oprot : Protocol.t) =
    oprot#writeStructBegin "SchemaDisagreementException";
    oprot#writeFieldStop;
    oprot#writeStructEnd
end
exception SchemaDisagreementException of schemaDisagreementException
let rec read_schemaDisagreementException (iprot : Protocol.t) =
  let _str448 = new schemaDisagreementException in
    ignore(iprot#readStructBegin);
    (try while true do
        let (_,_t449,_id450) = iprot#readFieldBegin in
        if _t449 = Protocol.T_STOP then
          raise Break
        else ();
        (match _id450 with 
          | _ -> iprot#skip _t449);
        iprot#readFieldEnd;
      done; ()
    with Break -> ());
    iprot#readStructEnd;
    _str448

